# RPC&GRPC

## 什么是RPC

1. RPC (Remote Procedure Call)远程过程调用，简单的理解是一个节点请求另一个节点提供的服务。
2. 对应rpc的是本地过程调用，函数调用是最常见的本地过程调用。
3. 将本地过程调用变成远程过程调用会面临各种问题。

## 本地过程调用

函数调用过程:

1. 将1和2压入add函数的栈
2. 进入add函数，从栈中取出1和2分别赋值给a和b
3. 执行a + b将结果赋值给局部的total并压栈
4. 将栈中的值取出来赋值给全局的total

### 远程过程面临的问题

1. 原本的本地函数放到另一个服务器上去运行。但是引入了很多新问题
2. Call的id映射
3. **序列化和反序列化**
4. **网络传输**

## go的grpc开发环境

### 安装protoc

生成protobuf文件的工具

放在$GOPATH/bin目录下，记得设置环境变量

[官方地址](https://github.com/protocolbuffers/protobuf/releases/tag/v3.19.4)

### 安装protoc-gen-go

将proto文件转为go代码的工具

[官方地址](https://github.com/golang/protobuf)

进入protoc-gen-go目录后 go install就会放在$GOPATH/bin目录下，记得设置环境变量

### 安装protoc-gen-go-grpc

将proto文件生成grpc代码的工具

[官方地址](https://github.com/grpc/grpc-go)

进入 cmd/protoc-gen-go-grpc 目录后 go install就会放在$GOPATH/bin目录下，记得设置环境变量

### 安装protoc-gen-validate

将proto文件生成验证器代码的工具

[官方文档](https://github.com/envoyproxy/protoc-gen-validate)

- windows下：

下载后，在包根目录直接go install 即可

## 远程过程调用带来的新问题

在远程调用时，我们需要执行的函数体是在远程的机器上的，也就是说，add是在另一个进程中执行的。这就带来了几个新问题:

1. **Call ID映射**。我们怎么告诉远程机器我们要调用add，而不是sub或者Foo呢?在本地调用中，函数体是直接
   通过函数指针来指定的，我们调用add，编译器就自动帮我们调用它相应的函数指计。但是任匹柱有用中，因数指针是不行的，因为两个进程的地址空间是完全不一样的。所以，在RPC中，所有的函数都必须有自己的一
   个ID。这个ID在所有进程中都是唯一确定的。客户端在做远程过程调用时，必须附上这个ID。然后我们还需要在客户端和服务端分别维护一个{函数<--> Call D}的对应表。两者的表不一定需要完全相同，但相同的函数对应的Call ID必须相同。当客户端需要进行远程调用时，它就查一下这个表，找出相应的Call ID，然后把它传给服务端，服务端也通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。
2. **序列化和反序列化**。客户端怎么把参数值传给远程的函数呢?在本地调用中，我们只需要把参数压到栈里，然后让函数自己去栈里读就行。但是在远程过程调用时，客户端跟服务端是不同的进程，不能通过内存来传递参数。甚至有时候客户端和服务端使用的都不是同一种语言（比如服务端用C++，客户端用Java或者Python)。这时候就需要客户端把参数先转成一个字节流，传给服务端后，再把字节流转成自己能读取的格式。这个过程叫序列化和反序列化。同理，从服务端返回的值也需要序列化反序列化的过程。
3. **网络传输**。远程调用往往用在网络上，客户端和服务端是通过网络连接的。所有的数据都需要通过网络传输，因此就需要有一个网络传输层。网络传输层需要把call ID和序列化后的参数字节流传给服务端，然后再把序列化后的调用结果传回客户端。只要能完成这两者的，都可以作为传输层使用。因此，它所使用的协议其实是不限的，能完成传输就行。尽管大部分RPC框架都使用TCP协议，但其实UDP也可以，而gRPC于脆就用HTTP2。Java的Netty也属于这层的东西。

### 需求：

- client：

```
//如同调用本地函数
func Add(a,b int){
	//传输协议http
	//http请求
	req := HttpReq.NewRequest()
	//http response
	res,_ := req.Get(fmt.Sprintf("http://localhost:8000/%s?a=%d&b=%d","add",a,b))
	//http请求体
	body,_ := res.Body()
	fmt.Println(string(body))
	repD := repData{}
	_ =json.Unmarshal(body, &repD)
	fmt.Println(repD.Data)
}
func main(){
	Add(3,5)
}
```

- server：

```go
func main(){
	//http://127.0.0.1:8000/add?a=1&b=2
	//http://127.0.0.1:8000?method=add&a=1&b=2
	//返回的格式： json{"data":3}
	//1. callID问题： r.URL.Path, 2.数据的传输协议，url参数传递协议
	//3. 网络传输协议TCP协议
	http.HandleFunc("/add", func(w http.ResponseWriter, r *http.Request){
		_ = r.ParseForm()

		fmt.Println("path: ", r.URL.Path)
		a,_ := strconv.Atoi(r.Form["a"][0])
		b,_ := strconv.Atoi(r.Form["b"][0])

		w.Header().Set("Content-Type", "application/json")//请求头设置
		jD, _ := json.Marshal(map[string]int{
			"data":a+b,
		})
		_,_ = w.Write(jD)
	})
	http.ListenAndServe("localhost:8000", nil)
}
```

### HelloWorld 服务实例

client：

```go
func main(){
	client, err := rpc.Dial("tcp", "localhost:8887")
	if err != nil{
		panic("连接失败")
	}
	//var reply *string = new(string)
	var reply string
	err = client.Call("HelloService.Hello", "flare", &reply)
	//serviceMethod的前缀好处是，指明了函数的作用域
	//client.Hello("flare",&reply)//不用自己封装方法
	if err != nil{
		panic("调用失败")
	}
	fmt.Println(reply)
}

```

server：

```go
//远端处理逻辑函数
func (s *HelloService)Hello(request string, reply *string) error{
	//返回值通过修改reply的值
	*reply = "Hello, "+request
	return nil
}

func main(){
	//1.实例化一个server
	listener, _ := net.Listen("tcp", ":8887")
	//2.注册处理逻辑 handler
	_ = rpc.RegisterName("HelloService", &HelloService{})
	//3.启动服务
	conn, _ := listener.Accept()
	rpc.ServeConn(conn)//使用rpc对该请求服务

//	一连串代码除了rpc的作用域代码，其他都是net包的代码，可以再封装
//	几个问题：
//1.call id
//2.序列化和反序列化
//可以跨语言调用 1.go的rpc的序列化和反序列化的协议（Gob) 2.替换成常见的序列化json
}
```



### json传输通信实例

client：

```go
func main(){
	//conn, err := rpc.Dial("tcp", "localhost:8887")//原先go的协议是Gob
	conn, err := net.Dial("tcp", "localhost:8887")
	if err != nil{
		panic("连接失败")
	}
	var reply string
	client := rpc.NewClientWithCodec(jsonrpc.NewClientCodec(conn))
	err = client.Call("HelloService.Hello", "flare", &reply)
	if err != nil{
		panic("调用失败")
	}
	fmt.Println(reply)
}

```

server：

```go
//远端处理逻辑函数
func (s *HelloService)Hello(request string, reply *string) error{
	//返回值通过修改reply的值
	*reply = "Hello, "+request
	return nil
}

func main(){
	//1.实例化一个server
	listener, _ := net.Listen("tcp", ":8887")
	//2.注册处理逻辑 handler
	_ = rpc.RegisterName("HelloService", &HelloService{})
	//3.启动服务
	for {//循环监听
		conn, _ := listener.Accept()
		go rpc.ServeCodec(jsonrpc.NewServerCodec(conn)) //单协程监听，需要用go使用多协程并发
	}

//	一连串代码除了rpc的作用域代码，其他都是net包的代码，可以再封装
//	几个问题：
//1.call id
//2.序列化和反序列化
//可以跨语言调用 1.go的rpc的序列化和反序列化的协议（Gob) 2.替换成常见的序列化json
}
```

### 更改rpc网络传输协议为http协议

client：

```go
func main(){
	//conn, err := rpc.Dial("tcp", "localhost:8887")//原先go的协议是Gob
	conn, err := net.Dial("tcp", "localhost:8887")
	if err != nil{
		panic("连接失败")
	}
	var reply string
	client := rpc.NewClientWithCodec(jsonrpc.NewClientCodec(conn))
	err = client.Call("HelloService.Hello", "flare", &reply)
	if err != nil{
		panic("调用失败")
	}
	fmt.Println(reply)
}
```

server：

```go

type HelloService struct{

}

//远端处理逻辑函数
func (s *HelloService)Hello(request string, reply *string) error{
	//返回值通过修改reply的值
	*reply = "Hello, "+request
	return nil
}

func main(){
	//1.实例化一个server
	_ = rpc.RegisterName("HelloService", &HelloService{})
	http.HandleFunc("/httprpc", func(w http.ResponseWriter, r *http.Request) {
		fmt.Println(r.URL.Path)
		var conn io.ReadWriteCloser = struct{//读写请求
			io.Writer
			io.ReadCloser
		}{
			Writer: w,
			ReadCloser: r.Body,
		}
		rpc.ServeRequest(jsonrpc.NewServerCodec(conn))//conn使用json编码
		fmt.Fprintf(w,"r.Body:%v\n\nr.Header:\n%v\n\nr.URL:%v\n\nr.Write(w):%v\n\nr.Response:%v\n\nr.Form:%v\n\n",
			r.Body,r.Header,r.URL,r.Write(w),r.Response,r.Form)
	})
	http.ListenAndServe(":8887", nil)
}
```

### 完整的RPC实例

client

```go
func main() {
	//conn, err := rpc.Dial("tcp", "localhost:8887")//原先go的协议是Gob
	//if err != nil{
	//	panic("连接失败")
	//}
	client := proxy.NewHelloServiceClient("tcp", "localhost:8887")
	var reply string
	//err = conn.Call(handler.HelloServiceName+".Hello", "flare", &reply)
	//if err != nil{
	//	panic("调用失败")
	//}
	err := client.Hello("flare", &reply)
	if err != nil {
		log.Fatal("err:",err)
	}
	fmt.Println(reply)
}

```

client_proxy(客户端存根)

```go

type HelloServiceStub struct {
	*rpc.Client
}

//在go中没有类，对象，就意味着没有初始化方法
func NewHelloServiceClient(protol, address string) HelloServiceStub {
	conn, err := rpc.Dial(protol, address)
	if err != nil {
		panic("connect fail")
	}
	return HelloServiceStub{conn}
}

func (c *HelloServiceStub) Hello(request string, reply *string) error {
	err := c.Call(handler.HelloServiceName+".Hello", request, &reply)
	return err
}

```

server

```go
//server，client调用函数名称问题
const HelloServiceName = "handler/HelloService"//路径作为名称

//server中函数的传输对象HelloService更改了
type NewHelloService struct{}
//我们关心的是这个结构体的名称还是这个结构体内的方法？别的包肯定关心方法

func (s *NewHelloService)Hello(request string, reply *string) error{
	*reply = "Hello, "+request
	return nil
}
```

server_proxy(服务端存根)

```go
func main(){
	listener, _ := net.Listen("tcp", ":8887")
	//_ = rpc.RegisterName(handler.HelloServiceName, &handler.HelloService{})
	serverProxy.ResgisterHelloService(&handler.NewHelloService{})
	for {
		conn, _ := listener.Accept()
		go rpc.ServeConn(conn)
	}
}
```

handler(控制器)

```go
type HelloServicer interface {
	// 实现了handler中NewHelloService的hello函数
	Hello(request string, reply *string) error
}

// ResgisterHelloService 如何做到和handler中对象的解耦？server关心的是函数->鸭子类型
//func ResgisterHelloService(srv handler.NewHelloService) {
//	rpc.RegisterName(handler.HelloServiceName, srv)
//}
//使用interface代替了这个对象
func ResgisterHelloService(srv HelloServicer) {
	rpc.RegisterName(handler.HelloServiceName, srv)
}

```

### RPC还有哪些需求

1. 自动生成server端的stub
2. 自动生成client端的stub
3. 能同时生成多种语言的stub

## 多种RPC对比

### rpc：server  && client

![img](https://img-blog.csdnimg.cn/20190614140010954.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM3NTU1MjA=,size_16,color_FFFFFF,t_70)

![img](https://img-blog.csdnimg.cn/20190614140054230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM3NTU1MjA=,size_16,color_FFFFFF,t_70)

### gRPC:server && client  实现grpc.pb.go

![img](https://img-blog.csdnimg.cn/20190614140715598.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM3NTU1MjA=,size_16,color_FFFFFF,t_70)

![img](https://img-blog.csdnimg.cn/20190614140415464.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM3NTU1MjA=,size_16,color_FFFFFF,t_70)

### micro-rpc:server && client micro.go

micro-rpc-server

![img](https://img-blog.csdnimg.cn/20190614141957457.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM3NTU1MjA=,size_16,color_FFFFFF,t_70)

![img](https://img-blog.csdnimg.cn/20190614142057856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM3NTU1MjA=,size_16,color_FFFFFF,t_70)

micro-rpc-client

![img](https://img-blog.csdnimg.cn/20190614154040931.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM3NTU1MjA=,size_16,color_FFFFFF,t_70)

![img](https://img-blog.csdnimg.cn/20190614154411360.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM3NTU1MjA=,size_16,color_FFFFFF,t_70)

启动：micro/rpc/web/main.go 和micro/rpc/srv/main.go 启动web服务和srv服务 访问：localhost:8500/

### micro-grpc:server && client: micro-grpc.pb.go

micro-grpc-server

![img](https://img-blog.csdnimg.cn/20190614154704481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM3NTU1MjA=,size_16,color_FFFFFF,t_70)

![img](https://img-blog.csdnimg.cn/20190614154858622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM3NTU1MjA=,size_16,color_FFFFFF,t_70)

micro-grpc-client

![img](https://img-blog.csdnimg.cn/20190614155056335.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM3NTU1MjA=,size_16,color_FFFFFF,t_70)

![img](https://img-blog.csdnimg.cn/20190614155224635.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTM3NTU1MjA=,size_16,color_FFFFFF,t_70)

总结起来，server端需要，rpc服务端=连接+rpc绑定连接，rpc绑定方法



## 什么是grpc和protobuf

### grpc

gRPC 是一个高性能、开源和通用的 RPC 框架，面向移动和 HTTP/2 设计。目前提供 C、Java 和 Go 语言版本，分别是：[grpc](https://github.com/grpc/grpc), [grpc-java](https://github.com/grpc/grpc-java), [grpc-go](https://github.com/grpc/grpc-go). 其中 C 版本支持 [C](https://github.com/grpc/grpc), [C++](https://github.com/grpc/grpc/tree/master/src/cpp), [Node.js](https://github.com/grpc/grpc/tree/master/src/node), [Python](https://github.com/grpc/grpc/tree/master/src/python), [Ruby](https://github.com/grpc/grpc/tree/master/src/ruby), [Objective-C](https://github.com/grpc/grpc/tree/master/src/objective-c), [PHP](https://github.com/grpc/grpc/tree/master/src/php) 和 [C#](https://github.com/grpc/grpc/tree/master/src/csharp) 支持.

[链接](https://github.com/grpc/grpc)![img](https://cdn.nlark.com/yuque/0/2020/png/159615/1597845741615-71007133-3879-4d1d-9baf-6fe8ea97ee37.png)

## protobuf

[官方文档](https://developers.google.com/protocol-buffers/docs/style)

java中的dubbo dubbo/rmi/hessian messagepack 如果你懂了协议完全有能力自己去实现一个协议

- 习惯用 `Json、XML` 数据存储格式的你们，相信大多都没听过`Protocol Buffer`
- `Protocol Buffer` 其实 是 `Google`出品的一种轻量 & 高效的结构化数据存储格式，性能比 `Json、XML` 真的强！太！多！

- protobuf经历了protobuf2和protobuf3，pb3比pb2简化了很多，目前主流的版本是pb3

![image-20220221032840189](http://myimg.go2flare.xyz/img/image-20220221032840189.png)

### 使用protocbuf作为数据的传输格式

client

```go
func main(){
	client, err := rpc.Dial("tcp", "localhost:8887")
	if err != nil{
		panic("连接失败")
	}
	//var reply *string = new(string)
	var reply string
	err = client.Call("HelloService.Hello", "flare", &reply)
	//serviceMethod的前缀好处是，指明了函数的作用域
	//client.Hello("flare",&reply)//不用自己封装方法
	if err != nil{
		panic("调用失败")
	}
	fmt.Println(reply)
}
```

proto/hello

```go
syntax = "proto3";

option go_package="./;hello";

service Hello{
  rpc Hello(HelloRequest) returns (Response); //hello接口
}

message HelloRequest{
  string name = 1;//1是编号
  int32 age = 2;
  repeated string courses = 3;//类似数组
}

message Response{
  string reply = 1;
}

```

proto/main

```go
type Hello struct{
	Name string `json:"name"`
	Age int `json:"age"`
	Courses []string `json:"courses"`
}

func main(){
	testStruct := Hello{Name:"flare",Age:55,Courses:[]string{"Math","English"}}
	jsonRsp, _ := json.Marshal(testStruct)
	fmt.Println(string(jsonRsp),len(jsonRsp))
	req := helloworld.HelloRequest{
		Name:"flare",
		Age: 55,
		Courses: []string{"Math","English"},
	}
	//proto能序列化的对象都是定义在proto文件中
	rsp,_ := proto.Marshal(&req)//编码原理varint
	fmt.Println(string(rsp), len(rsp))

	newReq := helloworld.HelloRequest{}
	_ = proto.Unmarshal(rsp,&newReq)//将rsp信息反序列化
	fmt.Println(newReq.Name,newReq.Age,newReq.Courses)
}

```

server

```go
type HelloService struct{

}

//远端处理逻辑函数
func (s *HelloService)Hello(request string, reply *string) error{
	//返回值通过修改reply的值
	*reply = "Hello, "+request
	return nil
}

func main(){
	//1.实例化一个server
	listener, _ := net.Listen("tcp", ":8887")
	//2.注册处理逻辑 handler
	_ = rpc.RegisterName("HelloService", &HelloService{})
	//3.启动服务
	conn, _ := listener.Accept()
	rpc.ServeConn(conn)//使用rpc对该请求服务

//	一连串代码除了rpc的作用域代码，其他都是net包的代码，可以再封装
//	几个问题：
//1.call id
//2.序列化和反序列化
//可以跨语言调用 1.go的rpc的序列化和反序列化的协议（Gob) 2.替换成常见的序列化json
}
```

## grpc四种数据流

之前我们讲了 grpc 怎么简单的使用 ，这次讲讲 grpc 中的 stream，srteam 顾名思义 就是 一种 流，可以源源不断的 推送 数据，很适合 传输一些大数据，或者 服务端 和 客户端 长时间 数据交互，比如 客户端 可以向 服务端 订阅 一个数据，服务端 就 可以利用 stream ，源源不断地 推送数据。

### 四种数据流

1. 简单模式（Simple RPC）
2. 服务端数据流模式（Server-side streaming RPC）
3. 客户端数据流模式（Client-side straming RPC）
4. 双向数据流模式（Bidirectional streaming RPC）

### 简单模式

这种模式最为传统，即客户端发起一次请求，服务端响应一个数据，

这和大家平时熟悉的RPC没有什么大的区别，所以不再详细介绍

proto:

```protobuf
syntax = "proto3";

option go_package="./;hello";

service Hello{
  rpc Hello(HelloRequest) returns (Response); //hello接口
}

message HelloRequest{
  string name = 1;//1是编号
  int32 age = 2;
  repeated string courses = 3;//类似数组
}

message Response{
  string reply = 1;
}
```

server:

```go
type HelloServer struct{
	hello.UnimplementedHelloServer
}
//远端处理逻辑函数
func (s *HelloServer)Hello(ctx context.Context, req *hello.HelloRequest) (*hello.Response, error) {
	//返回值通过修改reply的值
	return &hello.Response{
		Reply: "Hello, "+req.Name+" Your age: "+strconv.Itoa(int(req.Age)),
	},nil
}

func main(){
	g := grpc.NewServer()
	hello.RegisterHelloServer(g, &HelloServer{})
	listener, err := net.Listen("tcp",":8885")
	if err != nil{
		panic("failed to listen:" + err.Error())
	}
	err = g.Serve(listener)
	if err != nil{
		panic("fail to start grpc:"+err.Error())
	}
}
```

client:

```go 
var client hello.HelloClient

func main() {
	conn, err := grpc.Dial(":8885", grpc.WithInsecure())
	if err != nil {
		panic("连接失败")
	}
	defer conn.Close()
	client = hello.NewHelloClient(conn)
	rsp, err := client.Hello(context.Background(), &hello.HelloRequest{
		Name: "roger",
		Age: 88,
	})
	if err != nil {
		panic("调用失败")
	}
	fmt.Println(rsp.Reply)
}
```



### 服务端流式

这种模式是客户端发起一次请求，服务端返回一段连续的数据流。

**典型的例子**是客户端向服务端发送一个股票代码。服务端就把该股票的实时数据源源不断的返回给客户端

`服务端流式RPC`：客户端发送请求到服务器，拿到一个流去读取返回的消息序列。 客户端读取返回的流，直到里面没有任何消息。

#### 情景模拟：实时获取股票走势。

1.客户端要获取某原油股的实时走势，客户端发送一个请求

2.服务端实时返回该股票的走势

#### 新建proto文件[#](https://www.cnblogs.com/FireworksEasyCool/p/12693749.html#2068590686)

新建server_stream.proto文件

1.定义发送信息

```protobuf
// 定义发送请求信息
message SimpleRequest{
    // 定义发送的参数，采用驼峰命名方式，小写加下划线，如：student_name
    // 请求参数
    string data = 1;
}
```

2.定义接收信息

```protobuf
// 定义流式响应信息
message StreamResponse{
    // 流式响应数据
    string stream_value = 1;
}
```

3.定义服务方法ListValue

服务端流式rpc，只要在响应数据前添加stream即可

```protobuf
// 定义我们的服务（可定义多个服务,每个服务可定义多个接口）
service StreamServer{
    // 服务端流式rpc，在响应数据前添加stream
    rpc ListValue(SimpleRequest)returns(stream StreamResponse){};
}
```

4.编译proto文件

进入server_stream.proto所在目录，运行指令:

```shell
protoc --go_out=. --go-grpc_out=. ./*.proto
```

#### 创建Server端

1.定义我们的服务，并实现ListValue方法

```go
// SimpleService 定义我们的服务
type StreamService struct{}
// ListValue 实现ListValue方法
func (s *StreamService) ListValue(req *pb.SimpleRequest, srv pb.StreamServer_ListValueServer) error {
	for n := 0; n < 5; n++ {
		// 向流中发送消息， 默认每次send送消息最大长度为`math.MaxInt32`bytes
		err := srv.Send(&pb.StreamResponse{
			StreamValue: req.Data + strconv.Itoa(n),
		})
		if err != nil {
			return err
		}
	}
	return nil
}
```

初学者可能觉得比较迷惑，ListValue的参数和返回值是怎样确定的。其实这些都是编译proto时生成的.pb.go文件中有定义，我们只需要实现就可以了。

![image-20220221144451243](http://myimg.go2flare.xyz/img/image-20220221144451243.png)

2.启动gRPC服务器

```go
//	监听地址，协议
const (
Address string = ":8800"
NetWork string = "tcp"
)

//判断接口是否实现
var _ message.StreamServerServer = &StreamServer{}

func main(){
	listener, err := net.Listen(NetWork, Address)
	if err != nil{
		log.Fatalf("net.Listen err : %v",err)
	}
	log.Println(Address + " net.Listening...")
	//	新建一个grpc服务器
	//	默认单次接受最大长度为`1024*1024*4`bytes(4M)，
	//	单次发送消息最大长度为`math.MaxInt32`bytes
	grpc.NewServer(grpc.MaxRecvMsgSize(1024*1024*4),grpc.MaxSendMsgSize(math.MaxInt32))
	grpcServ := grpc.NewServer()
	message.RegisterStreamServerServer(grpcServ, &StreamServer{})
	//用服务器 Serve() 方法以及我们的端口信息区实现阻塞等待，直到进程被杀死或者 Stop() 被调用
	err = grpcServ.Serve(listener)
	if err != nil{
		log.Fatalf("grpcServ.Serve err : %v",err)
	}
}
```

运行服务端

```powershell
2022/02/21 14:46:21 :8800 net.Listening...
```

#### 创建Client端[#](https://www.cnblogs.com/FireworksEasyCool/p/12693749.html#4019751725)

1.创建handler调用服务端ListValue方法

```go
const Address string = ":8800"

var grpcCli message.StreamServerClient

//listValue 调用服务端的ListValue方法
func listValue(){
	//创建发送的结构体
	req := message.SimpleRequest{
		Data: "stream server grpc",
	}
	//调用服务的方法ListValue, 传参使用空的context
	stream, err := grpcCli.ListValue(context.Background(), &req)
	if err != nil{
		log.Fatalf("grpcCli.ListValue err : %v", err)
	}
	//Recv() 方法接收服务端消息，默认每次Recv()最大消息长度为`1024*1024*4`bytes(4M)
	for{
		res, err := stream.Recv()
		if err == io.EOF{//判断消息流是否结束
			break
		}
		if err != nil{
			log.Fatalf("Client stream.Recv err : %v", err)
		}
		log.Println(res.StreamValue)
	}
}
```

2.启动gRPC客户端

```go
func main(){
	//连接服务器
	conn, err := grpc.Dial(Address, grpc.WithInsecure())
	//grpc.Dial(Address, grpc.WithTransportCredentials())
	if err != nil{
		log.Fatalf("grpc.Dial err : %v",err)
	}
	defer conn.Close()
	//建立grpc连接
	grpcCli = message.NewStreamServerClient(conn)
	listValue()
}
```

运行客户端

```powershell
2022/02/21 15:25:00 stream server grpc0
2022/02/21 15:25:00 stream server grpc1
2022/02/21 15:25:00 stream server grpc2
2022/02/21 15:25:00 stream server grpc3
2022/02/21 15:25:00 stream server grpc4
```

客户端不断从服务端获取数据

#### 思考[#](https://www.cnblogs.com/FireworksEasyCool/p/12693749.html#1980015400)

假如服务端不停发送数据，类似获取股票走势实时数据，客户端能自己停止获取数据吗？

答案：可以的

1.我们把服务端的ListValue方法稍微修改

```go
// ListValue 实现ListValue方法
func (s *StreamService) ListValue(req *pb.SimpleRequest, srv pb.StreamServer_ListValueServer) error {
	for n := 0; n < 15; n++ {
		// 向流中发送消息， 默认每次send送消息最大长度为`math.MaxInt32`bytes
		err := srv.Send(&pb.StreamResponse{
			StreamValue: req.Data + strconv.Itoa(n),
		})
		if err != nil {
			return err
		}
		log.Println(n)
		time.Sleep(1 * time.Second)
	}
	return nil
}
```

2.再把客户端调用ListValue方法的实现稍作修改，就可以得到结果了

```go
Copy// listValue 调用服务端的ListValue方法
func listValue() {
	// 创建发送结构体
	req := pb.SimpleRequest{
		Data: "stream server grpc ",
	}
	// 调用我们的服务(Route方法)
	// 同时传入了一个 context.Context ，在有需要时可以让我们改变RPC的行为，比如超时/取消一个正在运行的RPC
	stream, err := grpcClient.ListValue(context.Background(), &req)
	if err != nil {
		log.Fatalf("Call ListStr err: %v", err)
	}
	for {
		//Recv() 方法接收服务端消息，默认每次Recv()最大消息长度为`1024*1024*4`bytes(4M)
		res, err := stream.Recv()
		// 判断消息流是否已经结束
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatalf("ListStr get stream err: %v", err)
		}
		// 打印返回值
		log.Println(res.StreamValue)
		break
	}
	//可以使用CloseSend()关闭stream，这样服务端就不会继续产生流消息
	//调用CloseSend()后，若继续调用Recv()，会重新激活stream，接着之前结果获取消息
	stream.CloseSend()
}
```

只需要调用`CloseSend()`方法，就可以关闭服务端的stream，让它停止发送数据。值得注意的是，调用`CloseSend()`后，若继续调用`Recv()`，会重新激活stream，接着当前的结果继续获取消息。

这能完美解决客户端`暂停`->`继续`获取数据的操作。

#### 总结[#](https://www.cnblogs.com/FireworksEasyCool/p/12693749.html#523064711)

本篇介绍了`服务端流式RPC`的简单使用，客户端发起一个请求，服务端不停返回数据，直到服务端停止发送数据或客户端主动停止接收数据为止。下篇将介绍`客户端流式RPC`。

教程源码地址：https://github.com/Bingjian-Zhu/go-grpc-example
参考：[gRPC官方文档中文版](http://doc.oschina.net/grpc?t=60133)

### 客户端流式

与服务端数据流模式相反，这次是客户端源源不断的向服务端发送数
据流，而在发送结束后，由服务端返回一个响应。

**典型的例子**是物联网终端向服务器报送数据。

上一篇介绍了`服务端流式RPC`，客户端发送请求到服务器，拿到一个流去读取返回的消息序列。 客户端读取返回的流的数据。本篇将介绍`客户端流式RPC`。

`客户端流式RPC`：与`服务端流式RPC`相反，客户端不断的向服务端发送数据流，而在发送结束后，由服务端返回一个响应。

#### 情景模拟：客户端大量数据上传到服务端。

### 新建proto文件

新建client_stream.proto文件

1.定义发送信息

```protobuf
//定义请求体
message StreamRequest{
//流式请求参数
  string stream_data = 1;
}
```

2.定义接收信息

```protobuf
//定义响应体
message SimpleResponse{
//  响应码
  int32 code = 1;
//  响应值
  string value = 2;
}
```

3.定义服务方法RouteList

客户端流式rpc，只要在请求的参数前添加stream即可

```protobuf
service StreamClient{
  // 客户端流式rpc，在请求的参数前添加stream
  rpc RList(stream StreamRequest)returns(SimpleResponse);
}
```

4.编译proto文件

进入client_stream.proto所在目录，运行指令:

```shell
protoc --go_out=. --go-grpc_out=. ./*.proto
```

### 创建Server端

1.定义我们的服务，并实现RouteList方法

```go

const(
	Address string = ":8900"
	NetWork string = "tcp"
)

type StreamServer struct{
	message.UnimplementedStreamClientServer
}

func (*StreamServer)RouteList(srv message.StreamClient_RouteListServer) error{
	for {
		res, err := srv.Recv()
		if err == io.EOF{
		//	正确读完数据，发送响应码
			return srv.SendAndClose(&message.SimpleResponse{Code: 200, Value: "接受完毕"})
		}
		if err!=nil{
			log.Fatalf("Server srv.Recv() err : %v", err)
		}
		log.Println("Receive Data : ", res.StreamData)
	}
}

```

2.启动gRPC服务器

```go

var _ message.StreamClientServer = &StreamServer{}

func main() {
	//	监听端口
	listener, err := net.Listen(NetWork, Address)
	if err != nil {
		log.Fatal("Server net.Listen : %v", err)
	}
	log.Println(Address + " net.Listening")
	//	初始化一个grpc服务器
	grpcSrv := grpc.NewServer()
	//	将实现的服务注册倒grpc服务器
	message.RegisterStreamClientServer(grpcSrv, &StreamServer{})
	//用服务器 Serve() 方法以及我们的端口信息区实现阻塞等待，直到进程被杀死或者 Stop() 被调用
	err = grpcSrv.Serve(listener)
	if err != nil {
		log.Fatal("Server grpcSrv.Serve : %v", err)
	}
}

```

运行服务端

```powershell
2022/02/21 16:56:28 :8900 net.Listening
```

### 创建Client端

1.创建调用服务端RouteList方法

```go
const (
	Address string = ":8900"
)

var streamClient message.StreamClientClient

func RouteList() {
	//	调用服务端RouteList方法，获取数据流
	stream, err := streamClient.RouteList(context.Background())
	if err != nil {
		log.Fatalf("Client streamClient.RouteList : %v", err)
	}
	//	发送消息
	for i := 0; i < 15; i++ {
		err = stream.Send(&message.StreamRequest{
			StreamData: "steam client grpc " + strconv.Itoa(i),
		})
		if err != nil {
			log.Fatalf("Client stream.Send : %v", err)
		}
		time.Sleep(time.Second)
	}
	res, err := stream.CloseAndRecv()
	if err != nil {
		log.Fatalf("Client get reponse err : %v", err)
	}
	log.Println(res)
}
```

2.启动gRPC客户端

```go
func main(){
	conn, err := grpc.Dial(Address, grpc.WithInsecure())
	if err != nil{
		log.Fatalf("Client grpc.Dial err : %v",err)
	}
	defer conn.Close()
	//建立grpc连接
	streamClient = message.NewStreamClientClient(conn)
	RouteList()
}

```

运行客户端

```powershell
2022/02/21 17:12:46 code:200 value:"接受完毕"
```

服务端不断从客户端获取到数据

```powershell
2022/02/21 17:10:36 :8900 net.Listening
2022/02/21 17:11:57 Receive Data :  steam client grpc 0
2022/02/21 17:11:57 Receive Data :  steam client grpc 1
2022/02/21 17:11:57 Receive Data :  steam client grpc 2
2022/02/21 17:11:57 Receive Data :  steam client grpc 3
2022/02/21 17:11:57 Receive Data :  steam client grpc 4
2022/02/21 17:11:57 Receive Data :  steam client grpc 5
...
```

### 思考

服务端在没有接受完消息时候能主动停止接收数据吗（很少有这种场景）？

答案：可以的，但是客户端代码需要注意EOF判断

1.我们把服务端的RouteList方法实现稍微修改，当接收到一条数据后马上调用SendAndClose()关闭stream.

```go
func (*StreamServer)RouteList(srv message.StreamClient_RouteListServer) error{
	for {
		res, err := srv.Recv()
		if err == io.EOF{
		//	正确读完数据，发送响应码
			return srv.SendAndClose(&message.SimpleResponse{Code: 200, Value: "接受完毕"})
		}
		if err!=nil{
			log.Fatalf("Server srv.Recv() err : %v", err)
		}
		log.Println("Receive Data : ", res.StreamData)
		return srv.SendAndClose(&message.SimpleResponse{Code: 200, Value: "接受完毕"})
	}
}

```

2.再把客户端调用RouteList方法的实现稍作修改

```go
Copy// routeList 调用服务端RouteList方法
func routeList() {
	//调用服务端RouteList方法，获流
	stream, err := streamClient.RouteList(context.Background())
	if err != nil {
		log.Fatalf("Upload list err: %v", err)
	}
	for n := 0; n < 5; n++ {
		//向流中发送消息
		err := stream.Send(&pb.StreamRequest{StreamData: "stream client rpc " + strconv.Itoa(n)})
		//发送也要检测EOF，当服务端在消息没接收完前主动调用SendAndClose()关闭stream，此时客户端还执行Send()，则会返回EOF错误，所以这里需要加上io.EOF判断
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatalf("stream request err: %v", err)
		}
	}
	//关闭流并获取返回的消息
	res, err := stream.CloseAndRecv()
	if err != nil {
		log.Fatalf("RouteList get response err: %v", err)
	}
	log.Println(res)
}
```

客户端Send()需要检测err是否为EOF，因为当服务端在消息没接收完前主动调用SendAndClose()关闭stream，若此时客户端继续执行Send()，则会返回EOF错误。

### 总结

本篇介绍了`客户端流式RPC`的简单使用，下篇将介绍`双向流式RPC`

### 双向数据流

  顾名思义，这是客户端和服务端都可以向对方发送数据流，这个时候双方

的数据可以同时互相发送，也就是可以实现实时交互。

**典型的例子**是聊天机器人。

`双向流式RPC`：客户端和服务端双方使用读写流去发送一个消息序列，两个流独立操作，双方可以同时发送和同时接收。

### 情景模拟：双方对话（可以一问一答、一问多答、多问一答，形式灵活）。

### 新建proto文件

新建both_stream.proto文件

1.定义发送信息

```protobuf
service StreamClient{
//   双向流式rpc，同时在请求参数前和响应参数前加上stream
  rpc RouteList(stream StreamRequest)returns(stream StreamResponse);
}
```

2.定义接收信息

```protobuf
//定义请求体
message StreamRequest{
//流式请求参数
  string question = 1;
}
```

3.定义服务方法Conversations

双向流式rpc，只要在请求的参数前和响应参数前都添加stream即可

```protobuf
//定义响应体
message StreamResponse{
//  流响应数据
  string answer = 1;
}
```

4.编译proto文件

进入both_stream.proto所在目录，运行指令:

```
protoc --go_out=plugins=grpc:./ ./both_stream.proto
```

### 创建Server端

1.定义我们的服务，并实现RouteList方法

这里简单实现对话中一问一答的形式

```go
const(
	Address string = ":8900"
	NetWork string = "tcp"
)


type StreamServer struct{
	message.UnimplementedStreamClientServer
}

func (*StreamServer)Conversation(srv message.StreamClient_ConversationServer) error{
	i:=0
	for {
		res, err := srv.Recv()
		if err == io.EOF{
		//	正确读完数据，发送响应码
			return nil
		}
		if err!=nil{
			log.Fatalf("Server srv.Recv() err : %v", err)
		}
		//向流发送响应消息体
		err = srv.Send(&message.StreamResponse{
			Answer: "From stream server answer: the "+ strconv.Itoa(i)+" question is "+res.Question,
		})
		if err != nil {
			log.Fatalf("Server srv.Send : %v", err)
		}
		//server端处打印出问题
		log.Printf("From stream client question: %s", res.Question)
		i++
	}
}

```

2.启动gRPC服务器

```go
var _ message.StreamClientServer = &StreamServer{}

func main() {
	//	监听端口
	listener, err := net.Listen(NetWork, Address)
	if err != nil {
		log.Fatal("Server net.Listen : %v", err)
	}
	log.Println(Address + " net.Listening")
	//	初始化一个grpc服务器
	grpcSrv := grpc.NewServer()
	//	将实现的服务注册倒grpc服务器
	message.RegisterStreamClientServer(grpcSrv, &StreamServer{})
	//用服务器 Serve() 方法以及我们的端口信息区实现阻塞等待，直到进程被杀死或者 Stop() 被调用
	err = grpcSrv.Serve(listener)
	if err != nil {
		log.Fatal("Server grpcSrv.Serve : %v", err)
	}
}
```

运行服务端

```powershell
2022/02/21 17:41:47 :8900 net.Listening
```

### 创建Client端

1.创建调用服务端Conversations方法

```go
const (
	Address string = ":8900"
)

var streamClient message.StreamClientClient

func RouteList() {
	//	调用服务端RouteList方法，获取数据流
	stream, err := streamClient.Conversation(context.Background())
	if err != nil {
		log.Fatalf("Client streamClient.RouteList : %v", err)
	}
	//	发送消息
	for i:=0; i<5; i++{
		err := stream.Send(&message.StreamRequest{
			Question: "stream client rpc "+strconv.Itoa(i),
		})
		if err != nil{
			log.Fatalf("Server stream.Send err : %v", err)
		}
		res,err := stream.Recv()
		if err == io.EOF{
			break
		}
		if err != nil{
			log.Fatalf("Server stream.Recv err : %v", err)
		}
		//响应值
		log.Printf(res.Answer)
	}
//	关闭流
	err = stream.CloseSend()
	if err != nil{
		log.Fatalf("Server stream.CloseSend err : %v", err)
	}
}

```

2.启动gRPC客户端

```go
func main(){
	conn, err := grpc.Dial(Address, grpc.WithInsecure())
	if err != nil{
		log.Fatalf("Client grpc.Dial err : %v",err)
	}
	defer conn.Close()
	//建立grpc连接
	streamClient = message.NewStreamClientClient(conn)
	RouteList()
}

```

运行客户端，获取到服务端的应答

```powershell
2022/02/21 17:50:55 :8900 net.Listening
2022/02/21 17:51:08 From stream client question: stream client rpc 0
2022/02/21 17:51:08 From stream client question: stream client rpc 1
2022/02/21 17:51:08 From stream client question: stream client rpc 2
2022/02/21 17:51:08 From stream client question: stream client rpc 3
2022/02/21 17:51:08 From stream client question: stream client rpc 4
```

服务端获取到来自客户端的提问

```powershell
2022/02/21 17:51:08 From stream server answer: the 0 question is stream client rpc 0
2022/02/21 17:51:08 From stream server answer: the 1 question is stream client rpc 1
2022/02/21 17:51:08 From stream server answer: the 2 question is stream client rpc 2
2022/02/21 17:51:08 From stream server answer: the 3 question is stream client rpc 3
2022/02/21 17:51:08 From stream server answer: the 4 question is stream client rpc 4
```

### 总结

本篇介绍了`双向流式RPC`的简单使用。

## 综合实例

proto

```protobuf
syntax = "proto3";//3 才支持grpc

option go_package = "./;message";

//grpc服务
service Greeter{
  //  分别为服务端流，客户端流，双向流
  rpc GetStream (StreamReqData) returns (stream StreamResData);
  rpc PutStream (stream StreamReqData) returns (StreamResData);
  rpc AllStream (stream StreamReqData) returns (stream StreamResData);
}

//stream请求体
message StreamReqData{
  string data = 1;
}
//stream响应体
message StreamResData{
  string data = 1;
}
```

server

```go

const (
	Address  string = ":8700"
	Protocol string = "tcp"
)

//实现接口的对象
type Server struct {
	message.UnimplementedGreeterServer
}

//服务端流
//可以先接收一个客户端的请求消息
func (s *Server) GetStream(req *message.StreamReqData, srv message.Greeter_GetStreamServer) (err error) {
	for i := 1; i < 5; i++ {
		err = srv.Send(&message.StreamRspData{Data: "客户：" + req.Data + "，服务端的消息 " + strconv.Itoa(i)})
		if err != nil {
			return
		}
		time.Sleep(time.Second)
	}
	return nil
}

//客户端流
func (s *Server) PutStream(srv message.Greeter_PutStreamServer) (err error) {
	for {
		if streamRsq, err := srv.Recv(); err == nil {
			log.Printf("%v\n",streamRsq.Data)
		} else {
			if err == io.EOF {
				log.Println("EOF")
				break
			}
			return err
		}
	}
	return nil
}

//双向流
func (s *Server) AllStream(srv message.Greeter_AllStreamServer) (err error) {
	//两个协程，先发送消息，再接收消息
	wg := sync.WaitGroup{}
	wg.Add(2)
	go func() {
		defer wg.Done()
		for {
			//接收到消息在服务端打印
			if streamReq, err := srv.Recv(); err == nil{
				log.Println(streamReq.Data)
			}else{
				if err == io.EOF{
					log.Println("EOF")
					break
				}
				log.Fatalf("Server srv.Recv err : %v\n ", err)
			}
		}
	}()
	go func() {
		defer wg.Done()
		i:=1
		for {
			//发送消息
			err = srv.Send(&message.StreamRspData{Data: "This is server message "+strconv.Itoa(i)})
			if err != nil {
				return
			}
			time.Sleep(time.Second)
			i++
		}
	}()
	wg.Wait()
	return nil
}

func main(){
//	监听端口
	listener, err := net.Listen(Protocol,Address)
	if err != nil{
		log.Fatalf("Server net.Listen err : %v", err)
	}
	log.Printf("Server listening on %v", Address)
//	创建grpc服务器
	grpcServer := grpc.NewServer()
//	将message中的服务注册到grpc服务器
	message.RegisterGreeterServer(grpcServer, &Server{})
//	服务连接
	err = grpcServer.Serve(listener)
	if err != nil{
		log.Fatalf("grpcServer.Serve : %v", err)
	}
}

```

client

```

const(
	Address string = ":8700"
)

var Client message.GreeterClient

//服务端 推送流
func GetStream() {
	//需要先发送一条客户端消息，才能接收到客户端推送流
	streamClient, err := Client.GetStream(context.Background(), &message.StreamReqData{
		Data : "游客12138",
	})
	if err != nil{
		log.Fatalf("Client.GetStream err : %v\n",err)
	}
	for {
		if streamData, err := streamClient.Recv(); err == nil{
			log.Printf("%v\n", streamData)
		}else{
			if err == io.EOF{
				log.Println("EOF")
				break
			}
			log.Fatalf("Client rsp.Recv err : %v\n",err)
		}
	}
}
//客户端 推送流
func PutStream() (){
	//直接发送推送流
	streamClient, err := Client.PutStream(context.Background())
	if err != nil{
		log.Fatalf("Client Client.PutStream : %v \n", err)
	}
	for i:=1; i<5; i++{
		streamClient.Send(&message.StreamReqData{Data: "客户端的消息 "+strconv.Itoa(i)})
		time.Sleep(time.Second)
	}
}
//双向流
func AllStream() (){
	//两个协程，先发送消息，再接收消息
	wg := sync.WaitGroup{}
	wg.Add(2)
	streamClient, err := Client.AllStream(context.Background())
	if err != nil {
		log.Fatalf("Client Client.AllStream err : %v\n",err)
	}
	go func() {
		defer wg.Done()
		i:=1
		for {
			//客户端发送消息
			err = streamClient.Send(&message.StreamReqData{Data: "This is client message "+strconv.Itoa(i)})
			if err != nil {
				log.Fatalf("Client streamClient.Send err : %v\n",err)
			}
			time.Sleep(time.Second)
			i++
		}
	}()
	go func() {
		defer wg.Done()
		for {
			//客户端接收消息
			if streamRsp, err :=streamClient.Recv(); err == nil{
				log.Println(streamRsp.Data)
			}else{
				if err == io.EOF{
					log.Println("EOF")
					break
				}
				log.Fatalf("Client streamClient.Recv : %v\n", err)
			}
		}
	}()
	wg.Wait()
}


func main(){
	conn, err := grpc.Dial(Address, grpc.WithInsecure())
	if err != nil{
		log.Fatalf("Client grpc.Dial : %v\n", err )
	}
	defer conn.Close()
//	使用conn连接生成client对象
	Client = message.NewGreeterClient(conn)
	GetStream()
	PutStream()
	AllStream()
}

```

## grpc进阶

### 前言[#](https://www.cnblogs.com/FireworksEasyCool/p/12702959.html#1617199432)

gRPC默认的请求的超时时间是很长的，当你没有设置请求超时时间时，所有在运行的请求都占用大量资源且可能运行很长的时间，导致服务资源损耗过高，使得后来的请求响应过慢，甚至会引起整个进程崩溃。

为了避免这种情况，我们的服务应该设置超时时间。前面的[入门教程](https://github.com/Bingjian-Zhu/go-grpc-example)提到，当客户端发起请求时候，需要传入上下文`context.Context`，用于结束`超时`或`取消`的请求。

本篇以[简单RPC](https://bingjian-zhu.github.io/2020/04/10/Go-gRPC教程-简单RPC（二）/)为例，介绍如何设置gRPC请求的超时时间。

### 客户端请求设置超时时间[#](https://www.cnblogs.com/FireworksEasyCool/p/12702959.html#3338326127)

修改调用服务端方法

1.把超时时间设置为当前时间+3秒

```go
clientDeadline := time.Now().Add(time.Duration(3 * time.Second))
	ctx, cancel := context.WithDeadline(ctx, clientDeadline)
	defer cancel()
```

2.响应错误检测中添加超时检测

```go
    // 传入超时时间为3秒的ctx
	res, err := grpcClient.Route(ctx, &req)
	if err != nil {
		//获取错误状态
		statu, ok := status.FromError(err)
		if ok {
			//判断是否为调用超时
			if statu.Code() == codes.DeadlineExceeded {
				log.Fatalln("Route timeout!")
			}
		}
		log.Fatalf("Call Route err: %v", err)
	}
	// 打印返回值
	log.Println(res.Value)
```

完整的[client.go](https://github.com/Bingjian-Zhu/go-grpc-example/blob/master/6-grpc_deadlines/client/client.go)代码

### 服务端判断请求是否超时[#](https://www.cnblogs.com/FireworksEasyCool/p/12702959.html#3623714587)

当请求超时后，服务端应该停止正在进行的操作，避免资源浪费。

```go
// Route 实现Route方法
func (s *SimpleService) Route(ctx context.Context, req *pb.SimpleRequest) (*pb.SimpleResponse, error) {
	data := make(chan *pb.SimpleResponse, 1)
	go handle(ctx, req, data)
	select {
	case res := <-data:
		return res, nil
	case <-ctx.Done():
		return nil, status.Errorf(codes.Canceled, "Client cancelled, abandoning.")
	}
}

func handle(ctx context.Context, req *pb.SimpleRequest, data chan<- *pb.SimpleResponse) {
	select {
	case <-ctx.Done():
		log.Println(ctx.Err())
		runtime.Goexit() //超时后退出该Go协程
	case <-time.After(4 * time.Second): // 模拟耗时操作
		res := pb.SimpleResponse{
			Code:  200,
			Value: "hello " + req.Data,
		}
		// //修改数据库前进行超时判断
		// if ctx.Err() == context.Canceled{
		// 	...
		// 	//如果已经超时，则退出
		// }
		data <- &res
	}
}
```

一般地，在写库前进行超时检测，发现超时就停止工作。

完整[server.go](https://github.com/Bingjian-Zhu/go-grpc-example/tree/master/6-grpc_deadlines/server/server.go)代码

### 运行结果[#](https://www.cnblogs.com/FireworksEasyCool/p/12702959.html#3170010614)

服务端：

```powershell
Copy:8000 net.Listing...
goroutine still running
```

客户端：

```powershell
CopyRoute timeout!
```

### 总结[#](https://www.cnblogs.com/FireworksEasyCool/p/12702959.html#1022258171)

超时时间的长短需要根据自身服务而定，例如返回一个`hello grpc`，可能只需要几十毫秒，然而处理大量数据的同步操作则可能要很长时间。需要考虑多方面因素来决定这个超时时间，例如系统间端到端的延时，哪些RPC是串行的，哪些是可以并行的等等。

教程源码地址：https://github.com/Bingjian-Zhu/go-grpc-example
参考：https://grpc.io/blog/deadlines/

### 前言[#](https://www.cnblogs.com/FireworksEasyCool/p/12710325.html#681889942)

前面篇章的gRPC都是明文传输的，容易被篡改数据。本章将介绍如何为gRPC添加安全机制，包括TLS证书认证和Token认证。

### TLS证书认证[#](https://www.cnblogs.com/FireworksEasyCool/p/12710325.html#1566276272)

###### 什么是TLS

TLS（Transport Layer Security，安全传输层)，TLS是建立在`传输层`TCP协议之上的协议，服务于应用层，它的前身是SSL（Secure Socket Layer，安全套接字层），它实现了将应用层的报文进行加密后再交由TCP进行传输的功能。

###### TLS的作用

TLS协议主要解决如下三个网络安全问题。

- 保密(message privacy)，保密通过加密encryption实现，所有信息都加密传输，第三方无法嗅探；
- 完整性(message integrity)，通过MAC校验机制，一旦被篡改，通信双方会立刻发现；
- 认证(mutual authentication)，双方认证,双方都可以配备证书，防止身份被冒充；

#### 生成私钥

生成RSA私钥：`openssl genrsa -out server.key 2048`

> 生成RSA私钥，命令的最后一个参数，将指定生成密钥的位数，如果没有指定，默认512

生成ECC私钥：`openssl ecparam -genkey -name secp384r1 -out server.key`

> 生成ECC私钥，命令为椭圆曲线密钥参数生成及操作，本文中ECC曲线选择的是secp384r1

#### 生成公钥

```
openssl req -new -x509 -sha256 -key server.key -out server.pem -days 3650
```

> openssl req：生成自签名证书，-new指生成证书请求、-sha256指使用sha256加密、-key指定私钥文件、-x509指输出证书、-days 3650为有效期

此后则输入证书拥有者信息

```ruby
CopyCountry Name (2 letter code) [AU]:CN
State or Province Name (full name) [Some-State]:XxXx
Locality Name (eg, city) []:XxXx
Organization Name (eg, company) [Internet Widgits Pty Ltd]:XX Co. Ltd
Organizational Unit Name (eg, section) []:Dev
Common Name (e.g. server FQDN or YOUR name) []:go-grpc-example
Email Address []:xxx@xxx.com
```

#### 服务端构建TLS证书并认证

```go
Copyfunc main() {
	// 监听本地端口
	listener, err := net.Listen(Network, Address)
	if err != nil {
		log.Fatalf("net.Listen err: %v", err)
	}
	// 从输入证书文件和密钥文件为服务端构造TLS凭证
	creds, err := credentials.NewServerTLSFromFile("../pkg/tls/server.pem", "../pkg/tls/server.key")
	if err != nil {
		log.Fatalf("Failed to generate credentials %v", err)
	}
	// 新建gRPC服务器实例,并开启TLS认证
	grpcServer := grpc.NewServer(grpc.Creds(creds))
	// 在gRPC服务器注册我们的服务
	pb.RegisterSimpleServer(grpcServer, &SimpleService{})
	log.Println(Address + " net.Listing whth TLS and token...")
	//用服务器 Serve() 方法以及我们的端口信息区实现阻塞等待，直到进程被杀死或者 Stop() 被调用
	err = grpcServer.Serve(listener)
	if err != nil {
		log.Fatalf("grpcServer.Serve err: %v", err)
	}
}
```

- `credentials.NewServerTLSFromFile`：从输入证书文件和密钥文件为服务端构造TLS凭证
- `grpc.Creds`：返回一个ServerOption，用于设置服务器连接的凭证。

完整[server.go](https://github.com/Bingjian-Zhu/go-grpc-example/tree/master/7-grpc_security/server/server.go)代码

#### 客户端配置TLS连接

```go
Copyvar grpcClient pb.SimpleClient

func main() {
	//从输入的证书文件中为客户端构造TLS凭证
	creds, err := credentials.NewClientTLSFromFile("../pkg/tls/server.pem", "go-grpc-example")
	if err != nil {
		log.Fatalf("Failed to create TLS credentials %v", err)
	}
	// 连接服务器
	conn, err := grpc.Dial(Address, grpc.WithTransportCredentials(creds))
	if err != nil {
		log.Fatalf("net.Connect err: %v", err)
	}
	defer conn.Close()

	// 建立gRPC连接
	grpcClient = pb.NewSimpleClient(conn)
}
```

- `credentials.NewClientTLSFromFile`：从输入的证书文件中为客户端构造TLS凭证。
- `grpc.WithTransportCredentials`：配置连接级别的安全凭证（例如，TLS/SSL），返回一个DialOption，用于连接服务器。

完整[client.go](https://github.com/Bingjian-Zhu/go-grpc-example/tree/master/7-grpc_security/client/client.go)代码

到这里，已经完成TLS证书认证了，gRPC传输不再是明文传输。此外，添加自定义的验证方法能使gRPC相对更安全。下面以Token认证为例，介绍gRPC如何添加自定义验证方法。

### Token认证[#](https://www.cnblogs.com/FireworksEasyCool/p/12710325.html#2153718964)

客户端发请求时，添加Token到上下文`context.Context`中，服务器接收到请求，先从上下文中获取Token验证，验证通过才进行下一步处理。

#### 客户端请求添加Token到上下文中

```go
Copytype PerRPCCredentials interface {
    GetRequestMetadata(ctx context.Context, uri ...string) (map[string]string, error)
    RequireTransportSecurity() bool
}
```

gRPC 中默认定义了 `PerRPCCredentials`，是提供用于自定义认证的接口，它的作用是将所需的安全认证信息添加到每个RPC方法的上下文中。其包含 2 个方法：

- `GetRequestMetadata`：获取当前请求认证所需的元数据
- `RequireTransportSecurity`：是否需要基于 TLS 认证进行安全传输

接下来我们实现这两个方法

```go
Copy// Token token认证
type Token struct {
	AppID     string
	AppSecret string
}

// GetRequestMetadata 获取当前请求认证所需的元数据（metadata）
func (t *Token) GetRequestMetadata(ctx context.Context, uri ...string) (map[string]string, error) {
	return map[string]string{"app_id": t.AppID, "app_secret": t.AppSecret}, nil
}

// RequireTransportSecurity 是否需要基于 TLS 认证进行安全传输
func (t *Token) RequireTransportSecurity() bool {
	return true
}
```

然后再客户端中调用Dial时添加自定义验证方法进去

```go
Copy//构建Token
	token := auth.Token{
		AppID:     "grpc_token",
		AppSecret: "123456",
	}
	// 连接服务器
	conn, err := grpc.Dial(Address, grpc.WithTransportCredentials(creds), grpc.WithPerRPCCredentials(&token))
```

完整[client.go](https://github.com/Bingjian-Zhu/go-grpc-example/tree/master/7-grpc_security/client/client.go)代码

#### 服务端验证Token

首先需要从上下文中获取元数据，然后从元数据中解析Token进行验证

```go
Copy// Check 验证token
func Check(ctx context.Context) error {
	//从上下文中获取元数据
	md, ok := metadata.FromIncomingContext(ctx)
	if !ok {
		return status.Errorf(codes.Unauthenticated, "获取Token失败")
	}
	var (
		appID     string
		appSecret string
	)
	if value, ok := md["app_id"]; ok {
		appID = value[0]
	}
	if value, ok := md["app_secret"]; ok {
		appSecret = value[0]
	}
	if appID != "grpc_token" || appSecret != "123456" {
		return status.Errorf(codes.Unauthenticated, "Token无效: app_id=%s, app_secret=%s", appID, appSecret)
	}
	return nil
}

// Route 实现Route方法
func (s *SimpleService) Route(ctx context.Context, req *pb.SimpleRequest) (*pb.SimpleResponse, error) {
    //检测Token是否有效
	if err := Check(ctx); err != nil {
		return nil, err
	}
	res := pb.SimpleResponse{
		Code:  200,
		Value: "hello " + req.Data,
	}
	return &res, nil
}
```

- `metadata.FromIncomingContext`：从上下文中获取元数据

完整[server.go](https://github.com/Bingjian-Zhu/go-grpc-example/tree/master/7-grpc_security/server/server.go)代码

服务端代码中，每个服务的方法都需要添加Check(ctx)来验证Token，这样十分麻烦。gRPC拦截器，能很好地解决这个问题。gRPC拦截器功能类似中间件，拦截器收到请求后，先进行一些操作，然后才进入服务的代码处理。

### 服务端添加拦截器[#](https://www.cnblogs.com/FireworksEasyCool/p/12710325.html#1637658163)

```go
Copyfunc main() {
	// 监听本地端口
	listener, err := net.Listen(Network, Address)
	if err != nil {
		log.Fatalf("net.Listen err: %v", err)
	}
	// 从输入证书文件和密钥文件为服务端构造TLS凭证
	creds, err := credentials.NewServerTLSFromFile("../pkg/tls/server.pem", "../pkg/tls/server.key")
	if err != nil {
		log.Fatalf("Failed to generate credentials %v", err)
	}
	//普通方法：一元拦截器（grpc.UnaryInterceptor）
	var interceptor grpc.UnaryServerInterceptor
	interceptor = func(ctx context.Context, req interface{}, info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (resp interface{}, err error) {
		//拦截普通方法请求，验证Token
		err = Check(ctx)
		if err != nil {
			return
		}
		// 继续处理请求
		return handler(ctx, req)
	}
	// 新建gRPC服务器实例,并开启TLS认证和Token认证
	grpcServer := grpc.NewServer(grpc.Creds(creds), grpc.UnaryInterceptor(interceptor))
	// 在gRPC服务器注册我们的服务
	pb.RegisterSimpleServer(grpcServer, &SimpleService{})
	log.Println(Address + " net.Listing whth TLS and token...")
	//用服务器 Serve() 方法以及我们的端口信息区实现阻塞等待，直到进程被杀死或者 Stop() 被调用
	err = grpcServer.Serve(listener)
	if err != nil {
		log.Fatalf("grpcServer.Serve err: %v", err)
	}
}
```

- `grpc.UnaryServerInterceptor`：为一元拦截器，只会拦截简单RPC方法。流式RPC方法需要使用流式拦截器`grpc.StreamInterceptor`进行拦截。

客户端发起请求，当Token不正确时候，会返回

```powershell
CopyCall Route err: rpc error: code = Unauthenticated desc = Token无效: app_id=grpc_token, app_secret=12345
```

### 总结[#](https://www.cnblogs.com/FireworksEasyCool/p/12710325.html#4218643469)

本篇介绍如何为gRPC添加TLS证书认证和自定义认证，从而让gRPC更安全。添加gRPC拦截器，从而省略在每个方法前添加Token检测代码，使代码更简洁。

教程源码地址：https://github.com/Bingjian-Zhu/go-grpc-example

参考：

> - https://www.jianshu.com/p/1fc7130eb2c2
> - https://segmentfault.com/a/1190000007933303
> - https://eddycjy.com/posts/go/grpc/2018-10-07-grpc-tls/
> - https://segmentfault.com/a/1190000007997759
> - https://eddycjy.com/posts/go/grpc/2018-10-10-interceptor/

### go-grpc-middleware使用

### 前言[#](https://www.cnblogs.com/FireworksEasyCool/p/12750339.html#3128510556)

上篇介绍了gRPC中TLS认证和自定义方法认证，最后还简单介绍了gRPC拦截器的使用。gRPC自身只能设置一个拦截器，所有逻辑都写一起会比较乱。本篇简单介绍[go-grpc-middleware](https://github.com/grpc-ecosystem/go-grpc-middleware)的使用，包括`grpc_zap`、`grpc_auth`和`grpc_recovery`。

### go-grpc-middleware简介[#](https://www.cnblogs.com/FireworksEasyCool/p/12750339.html#693834532)

go-grpc-middleware封装了认证（auth）, 日志（ logging）, 消息（message）, 验证（validation）, 重试（retries） 和监控（retries）等拦截器。

- 安装 `go get github.com/grpc-ecosystem/go-grpc-middleware`
- 使用

```go
Copyimport "github.com/grpc-ecosystem/go-grpc-middleware"
myServer := grpc.NewServer(
    grpc.StreamInterceptor(grpc_middleware.ChainStreamServer(
        grpc_ctxtags.StreamServerInterceptor(),
        grpc_opentracing.StreamServerInterceptor(),
        grpc_prometheus.StreamServerInterceptor,
        grpc_zap.StreamServerInterceptor(zapLogger),
        grpc_auth.StreamServerInterceptor(myAuthFunction),
        grpc_recovery.StreamServerInterceptor(),
    )),
    grpc.UnaryInterceptor(grpc_middleware.ChainUnaryServer(
        grpc_ctxtags.UnaryServerInterceptor(),
        grpc_opentracing.UnaryServerInterceptor(),
        grpc_prometheus.UnaryServerInterceptor,
        grpc_zap.UnaryServerInterceptor(zapLogger),
        grpc_auth.UnaryServerInterceptor(myAuthFunction),
        grpc_recovery.UnaryServerInterceptor(),
    )),
)
```

`grpc.StreamInterceptor`中添加流式RPC的拦截器。
`grpc.UnaryInterceptor`中添加简单RPC的拦截器。

### grpc_zap日志记录[#](https://www.cnblogs.com/FireworksEasyCool/p/12750339.html#4283915007)

1.创建zap.Logger实例

```go
Copyfunc ZapInterceptor() *zap.Logger {
	logger, err := zap.NewDevelopment()
	if err != nil {
		log.Fatalf("failed to initialize zap logger: %v", err)
	}
	grpc_zap.ReplaceGrpcLogger(logger)
	return logger
}
```

2.把zap拦截器添加到服务端

```go
CopygrpcServer := grpc.NewServer(
	grpc.StreamInterceptor(grpc_middleware.ChainStreamServer(
			grpc_zap.StreamServerInterceptor(zap.ZapInterceptor()),
		)),
		grpc.UnaryInterceptor(grpc_middleware.ChainUnaryServer(
			grpc_zap.UnaryServerInterceptor(zap.ZapInterceptor()),
		)),
	)
```

3.日志分析

[![img](https://img2020.cnblogs.com/blog/1508611/202004/1508611-20200421150239484-1399156155.png)](https://img2020.cnblogs.com/blog/1508611/202004/1508611-20200421150239484-1399156155.png)
各个字段代表的意思如下：

```json
Copy{
	  "level": "info",						// string  zap log levels
	  "msg": "finished unary call",					// string  log message

	  "grpc.code": "OK",						// string  grpc status code
	  "grpc.method": "Ping",					/ string  method name
	  "grpc.service": "mwitkow.testproto.TestService",              // string  full name of the called service
	  "grpc.start_time": "2006-01-02T15:04:05Z07:00",               // string  RFC3339 representation of the start time
	  "grpc.request.deadline": "2006-01-02T15:04:05Z07:00",         // string  RFC3339 deadline of the current request if supplied
	  "grpc.request.value": "something",				// string  value on the request
	  "grpc.time_ms": 1.345,					// float32 run time of the call in ms

	  "peer.address": {
	    "IP": "127.0.0.1",						// string  IP address of calling party
	    "Port": 60216,						// int     port call is coming in on
	    "Zone": ""							// string  peer zone for caller
	  },
	  "span.kind": "server",					// string  client | server
	  "system": "grpc",						// string

	  "custom_field": "custom_value",				// string  user defined field
	  "custom_tags.int": 1337,					// int     user defined tag on the ctx
	  "custom_tags.string": "something"				// string  user defined tag on the ctx
}
```

4.把日志写到文件中

上面日志是在控制台输出的，现在我们把日志写到文件中，修改`ZapInterceptor`方法。

```go
Copyimport (
	grpc_zap "github.com/grpc-ecosystem/go-grpc-middleware/logging/zap"
	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
	"gopkg.in/natefinch/lumberjack.v2"
)

// ZapInterceptor 返回zap.logger实例(把日志写到文件中)
func ZapInterceptor() *zap.Logger {
	w := zapcore.AddSync(&lumberjack.Logger{
		Filename:  "log/debug.log",
		MaxSize:   1024, //MB
		LocalTime: true,
	})

	config := zap.NewProductionEncoderConfig()
	config.EncodeTime = zapcore.ISO8601TimeEncoder
	core := zapcore.NewCore(
		zapcore.NewJSONEncoder(config),
		w,
		zap.NewAtomicLevel(),
	)

	logger := zap.New(core, zap.AddCaller(), zap.AddCallerSkip(1))
	grpc_zap.ReplaceGrpcLogger(logger)
	return logger
}
```

### grpc_auth认证[#](https://www.cnblogs.com/FireworksEasyCool/p/12750339.html#3589772431)

go-grpc-middleware中的grpc_auth默认使用`authorization`认证方式，以authorization为头部，包括`basic`, `bearer`形式等。下面介绍`bearer token`认证。`bearer`允许使用`access key`（如JSON Web Token (JWT)）进行访问。

1.新建grpc_auth服务端拦截器

```go
Copy// TokenInfo 用户信息
type TokenInfo struct {
	ID    string
	Roles []string
}

// AuthInterceptor 认证拦截器，对以authorization为头部，形式为`bearer token`的Token进行验证
func AuthInterceptor(ctx context.Context) (context.Context, error) {
	token, err := grpc_auth.AuthFromMD(ctx, "bearer")
	if err != nil {
		return nil, err
	}
	tokenInfo, err := parseToken(token)
	if err != nil {
		return nil, grpc.Errorf(codes.Unauthenticated, " %v", err)
	}
	//使用context.WithValue添加了值后，可以用Value(key)方法获取值
	newCtx := context.WithValue(ctx, tokenInfo.ID, tokenInfo)
	//log.Println(newCtx.Value(tokenInfo.ID))
	return newCtx, nil
}

//解析token，并进行验证
func parseToken(token string) (TokenInfo, error) {
	var tokenInfo TokenInfo
	if token == "grpc.auth.token" {
		tokenInfo.ID = "1"
		tokenInfo.Roles = []string{"admin"}
		return tokenInfo, nil
	}
	return tokenInfo, errors.New("Token无效: bearer " + token)
}

//从token中获取用户唯一标识
func userClaimFromToken(tokenInfo TokenInfo) string {
	return tokenInfo.ID
}
```

代码中的对token进行简单验证并返回模拟数据。

2.客户端请求添加`bearer token`

实现和上篇的自定义认证方法大同小异。gRPC 中默认定义了 `PerRPCCredentials`，是提供用于自定义认证的接口，它的作用是将所需的安全认证信息添加到每个RPC方法的上下文中。其包含 2 个方法：

- `GetRequestMetadata`：获取当前请求认证所需的元数据
- `RequireTransportSecurity`：是否需要基于 TLS 认证进行安全传输

接下来我们实现这两个方法

```go
Copy// Token token认证
type Token struct {
	Value string
}

const headerAuthorize string = "authorization"

// GetRequestMetadata 获取当前请求认证所需的元数据
func (t *Token) GetRequestMetadata(ctx context.Context, uri ...string) (map[string]string, error) {
	return map[string]string{headerAuthorize: t.Value}, nil
}

// RequireTransportSecurity 是否需要基于 TLS 认证进行安全传输
func (t *Token) RequireTransportSecurity() bool {
	return true
}
```

> 注意：这里要以`authorization`为头部，和服务端对应。

发送请求时添加token

```go
Copy//从输入的证书文件中为客户端构造TLS凭证
	creds, err := credentials.NewClientTLSFromFile("../tls/server.pem", "go-grpc-example")
	if err != nil {
		log.Fatalf("Failed to create TLS credentials %v", err)
	}
	//构建Token
	token := auth.Token{
		Value: "bearer grpc.auth.token",
	}
	// 连接服务器
	conn, err := grpc.Dial(Address, grpc.WithTransportCredentials(creds), grpc.WithPerRPCCredentials(&token))
```

> 注意：Token中的Value的形式要以`bearer token值`形式。因为我们服务端使用了`bearer token`验证方式。

3.把grpc_auth拦截器添加到服务端

```go
CopygrpcServer := grpc.NewServer(cred.TLSInterceptor(),
	grpc.StreamInterceptor(grpc_middleware.ChainStreamServer(
	        grpc_auth.StreamServerInterceptor(auth.AuthInterceptor),
			grpc_zap.StreamServerInterceptor(zap.ZapInterceptor()),
		)),
		grpc.UnaryInterceptor(grpc_middleware.ChainUnaryServer(
		    grpc_auth.UnaryServerInterceptor(auth.AuthInterceptor),
			grpc_zap.UnaryServerInterceptor(zap.ZapInterceptor()),
		)),
	)
```

写到这里，服务端都会拦截请求并进行`bearer token`验证，使用`bearer token`是规范了与`HTTP`请求的对接，毕竟gRPC也可以同时支持`HTTP`请求。

### grpc_recovery恢复[#](https://www.cnblogs.com/FireworksEasyCool/p/12750339.html#1808507536)

把gRPC中的`panic`转成`error`，从而恢复程序。

1.直接把grpc_recovery拦截器添加到服务端

最简单使用方式

```go
CopygrpcServer := grpc.NewServer(cred.TLSInterceptor(),
	grpc.StreamInterceptor(grpc_middleware.ChainStreamServer(
	        grpc_auth.StreamServerInterceptor(auth.AuthInterceptor),
			grpc_zap.StreamServerInterceptor(zap.ZapInterceptor()),
			grpc_recovery.StreamServerInterceptor,
		)),
		grpc.UnaryInterceptor(grpc_middleware.ChainUnaryServer(
		    grpc_auth.UnaryServerInterceptor(auth.AuthInterceptor),
			grpc_zap.UnaryServerInterceptor(zap.ZapInterceptor()),
            grpc_recovery.UnaryServerInterceptor(),
		)),
	)
```

2.自定义错误返回

当`panic`时候，自定义错误码并返回。

```go
Copy// RecoveryInterceptor panic时返回Unknown错误吗
func RecoveryInterceptor() grpc_recovery.Option {
	return grpc_recovery.WithRecoveryHandler(func(p interface{}) (err error) {
		return grpc.Errorf(codes.Unknown, "panic triggered: %v", p)
	})
}
```

添加grpc_recovery拦截器到服务端

```go
CopygrpcServer := grpc.NewServer(cred.TLSInterceptor(),
	grpc.StreamInterceptor(grpc_middleware.ChainStreamServer(
	        grpc_auth.StreamServerInterceptor(auth.AuthInterceptor),
			grpc_zap.StreamServerInterceptor(zap.ZapInterceptor()),
			grpc_recovery.StreamServerInterceptor(recovery.RecoveryInterceptor()),
		)),
		grpc.UnaryInterceptor(grpc_middleware.ChainUnaryServer(
		    grpc_auth.UnaryServerInterceptor(auth.AuthInterceptor),
			grpc_zap.UnaryServerInterceptor(zap.ZapInterceptor()),
            grpc_recovery.UnaryServerInterceptor(recovery.RecoveryInterceptor()),
		)),
	)
```

### 总结[#](https://www.cnblogs.com/FireworksEasyCool/p/12750339.html#2032511922)

本篇介绍了`go-grpc-middleware`中的`grpc_zap`、`grpc_auth`和`grpc_recovery`拦截器的使用。`go-grpc-middleware`中其他拦截器可参考[GitHub](https://github.com/grpc-ecosystem/go-grpc-middleware)学习使用。

教程源码地址：https://github.com/Bingjian-Zhu/go-grpc-example



### proto数据验证

上篇介绍了[go-grpc-middleware](https://github.com/grpc-ecosystem/go-grpc-middleware)的`grpc_zap`、`grpc_auth`和`grpc_recovery`使用，本篇将介绍`grpc_validator`，它可以对gRPC数据的输入和输出进行验证。

### 创建proto文件，添加验证规则[#](https://www.cnblogs.com/FireworksEasyCool/p/12761033.html#1668561531)

这里使用第三方插件[go-proto-validators](https://github.com/mwitkow/go-proto-validators)自动生成验证规则。

```
go get github.com/mwitkow/go-proto-validators
```

1.新建simple.proto文件

```protobuf
Copysyntax = "proto3";

package proto;

import "github.com/mwitkow/go-proto-validators/validator.proto";

message InnerMessage {
  // some_integer can only be in range (1, 100).
  int32 some_integer = 1 [(validator.field) = {int_gt: 0, int_lt: 100}];
  // some_float can only be in range (0;1).
  double some_float = 2 [(validator.field) = {float_gte: 0, float_lte: 1}];
}

message OuterMessage {
  // important_string must be a lowercase alpha-numeric of 5 to 30 characters (RE2 syntax).
  string important_string = 1 [(validator.field) = {regex: "^[a-z]{2,5}$"}];
  // proto3 doesn't have `required`, the `msg_exist` enforces presence of InnerMessage.
  InnerMessage inner = 2 [(validator.field) = {msg_exists : true}];
}

service Simple{
  rpc Route (InnerMessage) returns (OuterMessage){};
}
```

代码`import "github.com/mwitkow/go-proto-validators/validator.proto"`，文件`validator.proto`需要`import "google/protobuf/descriptor.proto";`包，不然会报错。

`google/protobuf`地址：https://github.com/protocolbuffers/protobuf/tree/master/src/google/protobuf/descriptor.proto

把`src`文件夹中的`protobuf`目录下载到GOPATH目录下。

2.编译simple.proto文件

```
go get github.com/mwitkow/go-proto-validators/protoc-gen-govalidators
```

指令编译：`protoc --govalidators_out=. --go_out=plugins=grpc:./ ./simple.proto`

> 或者使用`VSCode-proto3`插件，[第一篇](https://www.cnblogs.com/FireworksEasyCool/p/12669371.html)有介绍。只需要添加`"--govalidators_out=."`即可。

```swift
Copy    // vscode-proto3插件配置
    "protoc": {
        // protoc.exe所在目录
        "path": "C:\\Go\\bin\\protoc.exe",
        // 保存时自动编译
        "compile_on_save": true,
        "options": [
            // go编译输出指令
            "--go_out=plugins=grpc:.",
            "--govalidators_out=."
        ]
    },
```

编译完成后，自动生成`simple.pb.go`和`simple.validator.pb.go`文件，`simple.pb.go`文件不再介绍，我们看下`simple.validator.pb.go`文件。

```go
Copy// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: go-grpc-example/9-grpc_proto_validators/proto/simple.proto

package proto

import (
	fmt "fmt"
	math "math"
	proto "github.com/golang/protobuf/proto"
	_ "github.com/mwitkow/go-proto-validators"
	regexp "regexp"
	github_com_mwitkow_go_proto_validators "github.com/mwitkow/go-proto-validators"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

func (this *InnerMessage) Validate() error {
	if !(this.SomeInteger > 0) {
		return github_com_mwitkow_go_proto_validators.FieldError("SomeInteger", fmt.Errorf(`value '%v' must be greater than '0'`, this.SomeInteger))
	}
	if !(this.SomeInteger < 100) {
		return github_com_mwitkow_go_proto_validators.FieldError("SomeInteger", fmt.Errorf(`value '%v' must be less than '100'`, this.SomeInteger))
	}
	if !(this.SomeFloat >= 0) {
		return github_com_mwitkow_go_proto_validators.FieldError("SomeFloat", fmt.Errorf(`value '%v' must be greater than or equal to '0'`, this.SomeFloat))
	}
	if !(this.SomeFloat <= 1) {
		return github_com_mwitkow_go_proto_validators.FieldError("SomeFloat", fmt.Errorf(`value '%v' must be lower than or equal to '1'`, this.SomeFloat))
	}
	return nil
}

var _regex_OuterMessage_ImportantString = regexp.MustCompile(`^[a-z]{2,5}$`)

func (this *OuterMessage) Validate() error {
	if !_regex_OuterMessage_ImportantString.MatchString(this.ImportantString) {
		return github_com_mwitkow_go_proto_validators.FieldError("ImportantString", fmt.Errorf(`value '%v' must be a string conforming to regex "^[a-z]{2,5}$"`, this.ImportantString))
	}
	if nil == this.Inner {
		return github_com_mwitkow_go_proto_validators.FieldError("Inner", fmt.Errorf("message must exist"))
	}
	if this.Inner != nil {
		if err := github_com_mwitkow_go_proto_validators.CallValidatorIfExists(this.Inner); err != nil {
			return github_com_mwitkow_go_proto_validators.FieldError("Inner", err)
		}
	}
	return nil
}
```

里面自动生成了`message`中属性的验证规则。

### 把`grpc_validator`验证拦截器添加到服务端[#](https://www.cnblogs.com/FireworksEasyCool/p/12761033.html#3293506837)

```go
CopygrpcServer := grpc.NewServer(cred.TLSInterceptor(),
	grpc.StreamInterceptor(grpc_middleware.ChainStreamServer(
			grpc_validator.StreamServerInterceptor(),
	        grpc_auth.StreamServerInterceptor(auth.AuthInterceptor),
			grpc_zap.StreamServerInterceptor(zap.ZapInterceptor()),
			grpc_recovery.StreamServerInterceptor(recovery.RecoveryInterceptor()),
		)),
		grpc.UnaryInterceptor(grpc_middleware.ChainUnaryServer(
		    grpc_validator.UnaryServerInterceptor(),
		    grpc_auth.UnaryServerInterceptor(auth.AuthInterceptor),
			grpc_zap.UnaryServerInterceptor(zap.ZapInterceptor()),
            grpc_recovery.UnaryServerInterceptor(recovery.RecoveryInterceptor()),
		)),
	)
```

运行后，当输入数据验证失败后，会有以下错误返回

```powershell
CopyCall Route err: rpc error: code = InvalidArgument desc = invalid field SomeInteger: value '101' must be less than '100'
```

### 其他类型验证规则设置[#](https://www.cnblogs.com/FireworksEasyCool/p/12761033.html#4258300451)

`enum`验证

```protobuf
Copysyntax = "proto3";
package proto;
import "github.com/mwitkow/go-proto-validators/validator.proto";

message SomeMsg {
  Action do = 1 [(validator.field) = {is_in_enum : true}];
}

enum Action {
  ALLOW = 0;
  DENY = 1;
  CHILL = 2;
}
```

`UUID`验证

```protobuf
Copysyntax = "proto3";
package proto;
import "github.com/mwitkow/go-proto-validators/validator.proto";

message UUIDMsg {
  // user_id must be a valid version 4 UUID.
  string user_id = 1 [(validator.field) = {uuid_ver: 4, string_not_empty: true}];
}
```

### 总结[#](https://www.cnblogs.com/FireworksEasyCool/p/12761033.html#1064555170)

`go-grpc-middleware`中`grpc_validator`集成`go-proto-validators`，我们只需要在编写proto时设好验证规则，并把`grpc_validator`添加到gRPC服务端，就能完成gRPC的数据验证，很简单也很方便。

教程源码地址：https://github.com/Bingjian-Zhu/go-grpc-example

### grpc转http

### 前言[#](https://www.cnblogs.com/FireworksEasyCool/p/12782137.html#1157565505)

我们通常把`RPC`用作内部通信，而使用`Restful Api`进行外部通信。为了避免写两套应用，我们使用[grpc-gateway](https://github.com/grpc-ecosystem/grpc-gateway)把`gRPC`转成`HTTP`。服务接收到`HTTP`请求后，`grpc-gateway`把它转成`gRPC`进行处理，然后以`JSON`形式返回数据。本篇代码以上篇为基础，最终转成的`Restful Api`支持`bearer token`验证、数据验证，并添加`swagger`文档。

### gRPC转成HTTP[#](https://www.cnblogs.com/FireworksEasyCool/p/12782137.html#2143707378)

#### 编写和编译proto

1.编写simple.proto

```protobuf
Copysyntax = "proto3";

package proto;

import "github.com/mwitkow/go-proto-validators/validator.proto";
import "go-grpc-example/10-grpc-gateway/proto/google/api/annotations.proto";

message InnerMessage {
  // some_integer can only be in range (1, 100).
  int32 some_integer = 1 [(validator.field) = {int_gt: 0, int_lt: 100}];
  // some_float can only be in range (0;1).
  double some_float = 2 [(validator.field) = {float_gte: 0, float_lte: 1}];
}

message OuterMessage {
  // important_string must be a lowercase alpha-numeric of 5 to 30 characters (RE2 syntax).
  string important_string = 1 [(validator.field) = {regex: "^[a-z]{2,5}$"}];
  // proto3 doesn't have `required`, the `msg_exist` enforces presence of InnerMessage.
  InnerMessage inner = 2 [(validator.field) = {msg_exists : true}];
}

service Simple{
  rpc Route (InnerMessage) returns (OuterMessage){
      option (google.api.http) ={
          post:"/v1/example/route"
          body:"*"
      };
  }
}
```

可以看到，`proto`变化不大，只是添加了API的路由路径

```protobuf
Copy      option (google.api.http) ={
          post:"/v1/example/route"
          body:"*"
      };
```

2.编译`simple.proto`

`simple.proto`文件引用了`google/api/annotations.proto`（[来源](https://github.com/grpc-ecosystem/grpc-gateway/tree/master/third_party/googleapis/google/api)），先要把它编译了。我这里是把`google/`文件夹直接复制到项目中的`proto/`目录中进行编译。发现`annotations.proto`引用了`google/api/http.proto`，那把它也编译了。

进入`annotations.proto`所在目录，编译：

```powershell
Copyprotoc --go_out=plugins=grpc:./ ./http.proto
protoc --go_out=plugins=grpc:./ ./annotations.proto
```

进入`simple.proto`所在目录，编译：

```powershell
Copy#生成simple.validator.pb.go和simple.pb.go
protoc --govalidators_out=. --go_out=plugins=grpc:./ ./simple.proto
#生成simple.pb.gw.go
protoc --grpc-gateway_out=logtostderr=true:./ ./simple.proto
```

以上完成`proto`编译，接着修改服务端代码。

#### 服务端代码修改

1.`server/`文件夹下新建`gateway/`目录，然后在里面新建`gateway.go`文件

```go
Copypackage gateway

import (
	"context"
	"crypto/tls"
	"io/ioutil"
	"log"
	"net/http"
	"strings"

	pb "go-grpc-example/10-grpc-gateway/proto"
	"go-grpc-example/10-grpc-gateway/server/swagger"

	"github.com/grpc-ecosystem/grpc-gateway/runtime"
	"golang.org/x/net/http2"
	"golang.org/x/net/http2/h2c"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials"
	"google.golang.org/grpc/grpclog"
)

// ProvideHTTP 把gRPC服务转成HTTP服务，让gRPC同时支持HTTP
func ProvideHTTP(endpoint string, grpcServer *grpc.Server) *http.Server {
	ctx := context.Background()
	//获取证书
	creds, err := credentials.NewClientTLSFromFile("../tls/server.pem", "go-grpc-example")
	if err != nil {
		log.Fatalf("Failed to create TLS credentials %v", err)
	}
	//添加证书
	dopts := []grpc.DialOption{grpc.WithTransportCredentials(creds)}
	//新建gwmux，它是grpc-gateway的请求复用器。它将http请求与模式匹配，并调用相应的处理程序。
	gwmux := runtime.NewServeMux()
	//将服务的http处理程序注册到gwmux。处理程序通过endpoint转发请求到grpc端点
	err = pb.RegisterSimpleHandlerFromEndpoint(ctx, gwmux, endpoint, dopts)
	if err != nil {
		log.Fatalf("Register Endpoint err: %v", err)
	}
	//新建mux，它是http的请求复用器
	mux := http.NewServeMux()
	//注册gwmux
	mux.Handle("/", gwmux)
	log.Println(endpoint + " HTTP.Listing whth TLS and token...")
	return &http.Server{
		Addr:      endpoint,
		Handler:   grpcHandlerFunc(grpcServer, mux),
		TLSConfig: getTLSConfig(),
	}
}

// grpcHandlerFunc 根据不同的请求重定向到指定的Handler处理
func grpcHandlerFunc(grpcServer *grpc.Server, otherHandler http.Handler) http.Handler {
	return h2c.NewHandler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if r.ProtoMajor == 2 && strings.Contains(r.Header.Get("Content-Type"), "application/grpc") {
			grpcServer.ServeHTTP(w, r)
		} else {
			otherHandler.ServeHTTP(w, r)
		}
	}), &http2.Server{})
}

// getTLSConfig获取TLS配置
func getTLSConfig() *tls.Config {
	cert, _ := ioutil.ReadFile("../tls/server.pem")
	key, _ := ioutil.ReadFile("../tls/server.key")
	var demoKeyPair *tls.Certificate
	pair, err := tls.X509KeyPair(cert, key)
	if err != nil {
		grpclog.Fatalf("TLS KeyPair err: %v\n", err)
	}
	demoKeyPair = &pair
	return &tls.Config{
		Certificates: []tls.Certificate{*demoKeyPair},
		NextProtos:   []string{http2.NextProtoTLS}, // HTTP2 TLS支持
	}
}
```

它主要作用是把不用的请求重定向到指定的服务处理，从而实现把`HTTP`请求转到`gRPC`服务。

2.gRPC支持HTTP

```go
Copy    //使用gateway把grpcServer转成httpServer
	httpServer := gateway.ProvideHTTP(Address, grpcServer)
	if err = httpServer.Serve(tls.NewListener(listener, httpServer.TLSConfig)); err != nil {
		log.Fatal("ListenAndServe: ", err)
	}
```

#### 使用postman测试

[![img](https://img2020.cnblogs.com/blog/1508611/202004/1508611-20200426190917132-305705093.gif)](https://img2020.cnblogs.com/blog/1508611/202004/1508611-20200426190917132-305705093.gif)

在动图中可以看到，我们的`gRPC`服务已经同时支持`RPC`和`HTTP`请求了，而且API接口支持`bearer token`验证和数据验证。为了方便对接，我们把API接口生成`swagger`文档。

### 生成swagger文档[#](https://www.cnblogs.com/FireworksEasyCool/p/12782137.html#4077270965)

#### 生成swagger文档-simple.swagger.json

1.安装`protoc-gen-swagger`

```
go get -u github.com/grpc-ecosystem/grpc-gateway/protoc-gen-swagger
```

2.编译生成simple.swagger.json

到simple.proto文件目录下，编译：
`protoc --swagger_out=logtostderr=true:./ ./simple.proto`

> 再次提一下，本人在VSCode中使用`VSCode-proto3`插件，[第一篇](https://www.cnblogs.com/FireworksEasyCool/p/12669371.html)有介绍，只要保存，就会自动编译，很方便，无需记忆指令。完整配置如下：

```swift
Copy    // vscode-proto3插件配置
    "protoc": {
        // protoc.exe所在目录
        "path": "C:\\Go\\bin\\protoc.exe",
        // 保存时自动编译
        "compile_on_save": true,
        "options": [
            "--go_out=plugins=grpc:.",//在当前目录编译输出.pb.go文件
            "--govalidators_out=.",//在当前目录编译输出.validator.pb文件
            "--grpc-gateway_out=logtostderr=true:.",//在当前目录编译输出.pb.gw.go文件
            "--swagger_out=logtostderr=true:."//在当前目录编译输出.swagger.json文件
        ]
    }
```

编译生成后把需要的文件留下，不需要的删掉。

#### 把swagger-ui转成Go代码，备用

1.下载`swagger-ui`

[下载地址](https://github.com/swagger-api/swagger-ui)，把`dist`目录下的所有文件拷贝我们项目的`server/swagger/swagger-ui/`目录下。

2.把`Swagger UI`转换为Go代码

安装`go-bindata`：
`go get -u github.com/jteeuwen/go-bindata/...`

回到`server/`所在目录，运行指令把`Swagger UI`转成Go代码。
`go-bindata --nocompress -pkg swagger -o swagger/datafile.go swagger/swagger-ui/...`

- 这步有坑，必须要回到`main`函数所在的目录运行指令，因为生成的Go代码中的`_bindata` 映射了`swagger-ui`的路径，程序是根据这些路径来找页面的。如果没有在`main`函数所在的目录运行指令，则生成的路径不对，会报404，无法找到页面。本项目`server/`端的`main`函数在`server.go`中，所以在`server/`所在目录下运行指令。

```go
Copyvar _bindata = map[string]func() (*asset, error){
	"swagger/swagger-ui/favicon-16x16.png": swaggerSwaggerUiFavicon16x16Png,
	"swagger/swagger-ui/favicon-32x32.png": swaggerSwaggerUiFavicon32x32Png,
	"swagger/swagger-ui/index.html": swaggerSwaggerUiIndexHtml,
	"swagger/swagger-ui/oauth2-redirect.html": swaggerSwaggerUiOauth2RedirectHtml,
	"swagger/swagger-ui/swagger-ui-bundle.js": swaggerSwaggerUiSwaggerUiBundleJs,
	"swagger/swagger-ui/swagger-ui-bundle.js.map": swaggerSwaggerUiSwaggerUiBundleJsMap,
	"swagger/swagger-ui/swagger-ui-standalone-preset.js": swaggerSwaggerUiSwaggerUiStandalonePresetJs,
	"swagger/swagger-ui/swagger-ui-standalone-preset.js.map": swaggerSwaggerUiSwaggerUiStandalonePresetJsMap,
	"swagger/swagger-ui/swagger-ui.css": swaggerSwaggerUiSwaggerUiCss,
	"swagger/swagger-ui/swagger-ui.css.map": swaggerSwaggerUiSwaggerUiCssMap,
	"swagger/swagger-ui/swagger-ui.js": swaggerSwaggerUiSwaggerUiJs,
	"swagger/swagger-ui/swagger-ui.js.map": swaggerSwaggerUiSwaggerUiJsMap,
}
```

#### 对外提供swagger-ui

1.在`swagger/`目录下新建`swagger.go`文件

```go
Copypackage swagger

import (
	"log"
	"net/http"
	"path"
	"strings"

	assetfs "github.com/elazarl/go-bindata-assetfs"
)

//ServeSwaggerFile 把proto文件夹中的swagger.json文件暴露出去
func ServeSwaggerFile(w http.ResponseWriter, r *http.Request) {
	if !strings.HasSuffix(r.URL.Path, "swagger.json") {
		log.Printf("Not Found: %s", r.URL.Path)
		http.NotFound(w, r)
		return
	}

	p := strings.TrimPrefix(r.URL.Path, "/swagger/")
	// "../proto/"为.swagger.json所在目录
	p = path.Join("../proto/", p)

	log.Printf("Serving swagger-file: %s", p)

	http.ServeFile(w, r, p)
}

//ServeSwaggerUI 对外提供swagger-ui
func ServeSwaggerUI(mux *http.ServeMux) {
	fileServer := http.FileServer(&assetfs.AssetFS{
		Asset:    Asset,
		AssetDir: AssetDir,
		Prefix:   "swagger/swagger-ui", //swagger-ui文件夹所在目录
	})
	prefix := "/swagger-ui/"
	mux.Handle(prefix, http.StripPrefix(prefix, fileServer))
}
```

2.注册`swagger`

在`gateway.go`中添加如下代码

```go
Copy	//注册swagger
	mux.HandleFunc("/swagger/", swagger.ServeSwaggerFile)
	swagger.ServeSwaggerUI(mux)
```

到这里我们已经完成了`swagger`文档的添加工作了，由于谷歌浏览器不能使用自己制作的TLS证书，所以我们用火狐浏览器进行测试。

用火狐浏览器打开：https://127.0.0.1:8000/swagger-ui/

在最上面地址栏输入：https://127.0.0.1:8000/swagger/simple.swagger.json

然后就可以看到swagger生成的API文档了。

[![img](https://img2020.cnblogs.com/blog/1508611/202004/1508611-20200426200056107-1097342377.png)](https://img2020.cnblogs.com/blog/1508611/202004/1508611-20200426200056107-1097342377.png)

还有个问题，我们使用了bearer token进行接口验证的，怎么把`bearer token`也添加到swagger中呢？
最后我在`grpc-gateway`GitHub上的这个[Issues](https://github.com/grpc-ecosystem/grpc-gateway/issues/1089)找到解决办法。

#### 在swagger中配置`bearer token`

1.修改`simple.proto`文件

```protobuf
Copysyntax = "proto3";

package proto;

import "github.com/mwitkow/go-proto-validators/validator.proto";
import "go-grpc-example/10-grpc-gateway/proto/google/api/annotations.proto";
import "go-grpc-example/10-grpc-gateway/proto/google/options/annotations.proto";

message InnerMessage {
  // some_integer can only be in range (1, 100).
  int32 some_integer = 1 [(validator.field) = {int_gt: 0, int_lt: 100}];
  // some_float can only be in range (0;1).
  double some_float = 2 [(validator.field) = {float_gte: 0, float_lte: 1}];
}

message OuterMessage {
  // important_string must be a lowercase alpha-numeric of 5 to 30 characters (RE2 syntax).
  string important_string = 1 [(validator.field) = {regex: "^[a-z]{2,5}$"}];
  // proto3 doesn't have `required`, the `msg_exist` enforces presence of InnerMessage.
  InnerMessage inner = 2 [(validator.field) = {msg_exists : true}];
}

option (grpc.gateway.protoc_gen_swagger.options.openapiv2_swagger) = {
  security_definitions: {
    security: {
      key: "bearer"
      value: {
        type: TYPE_API_KEY
        in: IN_HEADER
        name: "Authorization"
        description: "Authentication token, prefixed by Bearer: Bearer <token>"
      }
    }
  }

  security: {
    security_requirement: {
      key: "bearer"
    }
  }

  info: {
		title: "grpc gateway sample";
		version: "1.0";	
		license: {
			name: "MIT";			
		};
  }

  schemes: HTTPS
};

service Simple{
  rpc Route (InnerMessage) returns (OuterMessage){
      option (google.api.http) ={
          post:"/v1/example/route"
          body:"*"
      };
      // //禁用bearer token
      // option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
      //   security: { } // Disable security key
      // };
  }
}
```

2.重新编译生成simple.swagger.json

大功告成！

#### 验证测试

1.添加`bearer token`

[![img](https://img2020.cnblogs.com/blog/1508611/202004/1508611-20200426201427202-713287948.gif)](https://img2020.cnblogs.com/blog/1508611/202004/1508611-20200426201427202-713287948.gif)

2.调用接口，正确返回数据

[![img](https://img2020.cnblogs.com/blog/1508611/202004/1508611-20200426201751447-2114446576.png)](https://img2020.cnblogs.com/blog/1508611/202004/1508611-20200426201751447-2114446576.png)

3.传递不合规则的数据，返回违反数据验证逻辑错误

[![img](https://img2020.cnblogs.com/blog/1508611/202004/1508611-20200426201907769-1849889200.png)](https://img2020.cnblogs.com/blog/1508611/202004/1508611-20200426201907769-1849889200.png)

### 总结[#](https://www.cnblogs.com/FireworksEasyCool/p/12782137.html#2157956743)

本篇介绍了如何使用`grpc-gateway`让`gRPC`同时支持HTTP，最终转成的`Restful Api`支持`bearer token`验证、数据验证。同时生成`swagger`文档，方便API接口对接。

教程源码地址：https://github.com/Bingjian-Zhu/go-grpc-example

参考文档：
https://eddycjy.com/tags/grpc-gateway/
https://segmentfault.com/a/1190000008106582



## protobuf基本类型和默认值

### 标量数值类型

| .proto Type | Notes                                                        | Go Type |
| :---------- | :----------------------------------------------------------- | :------ |
| double      |                                                              | float64 |
| float       |                                                              | float32 |
| int32       | 使用可变长度编码。对负数进行编码效率低下——如果您的字段可能有负值，请改用 sint32。 | int32   |
| int64       | 使用可变长度编码。对负数进行编码效率低下——如果您的字段可能有负值，请改用 sint64。 | int64   |
| uint32      | 使用可变长度编码。                                           | uint32  |
| uint64      | 使用可变长度编码。                                           | uint64  |
| sint32      | 使用可变长度编码。带符号的 int 值。这些比常规 int32 更有效地编码负数。 | int32   |
| sint64      | 使用可变长度编码。带符号的 int 值。这些比常规 int64 更有效地编码负数。 | int64   |
| fixed32     | 总是四个字节。如果值通常大于 2^28 ，则比 uint32 更有效。     | uint32  |
| fixed64     | 总是八个字节。如果值通常大于 2^56 ，则比 uint64 更有效。     | uint64  |
| sfixed32    | 总是四个字节。                                               | int32   |
| sfixed64    | 总是八个字节。                                               | int64   |
| bool        |                                                              | bool    |
| string      | 字符串必须始终包含 UTF-8 编码或 7 位 ASCII 文本，并且不能超过 2 32。 | string  |
| bytes       | 可能包含不超过 2^32的任意字节序列。                          | []byte  |

你可以在文章Protocol Buffer编码中，找到更多“列化消息时各种类型如何编码”的信息。
1.在java中，无符号32位和64位整型被表示成他们的整型对应形似，最高位被储存在标志位中。
2.对于所有的情况，设定值会执行类型检查以确保此值是有效。
3.64位或者无符号32位整型在解码时被表示成为ilong,但是在设置时可以使用int型值设定，在所有
的情况下，值必须符合其设置其类型的要求。
4. python中string被表示成在解码时表示成unicode。但是一个ASCIlstring可以被表示成str类型。
5. Integer在64位的机器上使用，string在32位机器上使用

### 默认值

当一个消息被解析的时候，如果被编码的信息不包含一个特定的singular元素，被解析的对象锁对应
的域被设置位一个默认值，对于不同类型指定如下:
●对于strings, 默认是一个空string
●对于bytes,默认是一个空的bytes
●对于bools,默认是false
●对于数值类型，默认是0
●对于枚举，默认是第一个定义的枚举值，必须为0; 
●对于消息类型(message) ，域没有被设置，确切的消息是根据语言确定的，详见generated
code guide
对于可重复域的默认值是空(通常情况下是对应语言中空列表)。
注:对于标量消息域，一旦消息被解析，就无法判断域释放被设置为默认值(例如，例如boolean
值是否被设置为false)还是根本没有被设置。你应该在定义你的消息类型时非常注意。例如，比
如你不应该定义boolean的默认值false作为任何行为的触发方式。也应该注意如果一个标量消息
域被设置为标志位，这个值不应该被序列化传输。
查看generated code guide选择你的语言的默认值的工作细节。



## option go_package

- 作用

在指定目录下生成pb.go文件

比如多个微服务需要将生成的pb文件统一放在一个文件夹管理

- 实例

```
option go_package = "../../commmon/stream/proto";
//相对路径往前退2个目录，创建在/commmon/stream/proto包下
```



## proto文件同步的坑

- proto文件中消息体后面数字是编号，相当于有一个id属性，顺序是固定的
- 而json可以无序，只要key对应上就可以赋值



## 一个proto引用另一个proto

- 使用import，自定义的proto和系统的proto都可

  ```protobuf
  import "google/protobuf/empty.proto";
  ```

- 如果需要使用到系统的对象，在import包进入可以看到包的位置

  ```protobuf
  option csharp_namespace = "Google.Protobuf.WellKnownTypes";
  option go_package = "github.com/golang/protobuf/ptypes/empty";
  option java_package = "com.google.protobuf";
  option java_outer_classname = "EmptyProto";
  option java_multiple_files = true;
  option objc_class_prefix = "GPB";
  option cc_enable_arenas = true;
  ```

- 导入go_package里的选项即可找到对应的对象

- 遇到找不到系统包，错误提示如下：

  ```protobuf
  google/protobuf/descriptor.proto: File not found.
  kratos/api/annotations.proto:9:1: Import "google/protobuf/descriptor.proto" was not found or had errors.
  kratos/api/annotations.proto:11:8: "google.protobuf.EnumOptions" is not defined.
  helloworld.proto:5:1: Import "kratos/api/annotations.proto" was not found or had errors.
  exit status 1
  wire: helloworld/cmd/helloworld: wrote C:\Users\dkzhang\go\src\github.com\dkzhang\helloworld\cmd\helloworld\wire_gen.go
  ```

- 解决办法：


下载https://github.com/protocolbuffers/protobuf源代码，提取src/google文件夹，复制到$GOPATH下/src路径下，重新generate即可通过

## protoc 命令重新归纳

**WINDOWS下**

### 如果没有import系统包

如："google/protobuf/empty.proto"

在当前proto文件的目录下

```shell
proto --go-grpc_out=. --go_out=. ./*.proto
```

```shell
protoc -I . --go-grpc_out=. --go_out=. *.proto
```

### 如果import系统包

在当前的proto文件目录下，使用相对路径，定位到你放置该包主目录的文件目录下

如：

```protobuf
import "google/protobuf/empty.proto"; 
```

该包的主目录就是google

该包我放置在：

```
%GOPATH%\src
```

proto文件放置在：

```
%GOPATH%\go_code\gp\08grpc_proto_transfer\proto_foo\hello
```

从proto到该包就是

```shell
../../../../../.
```

- **相对路径写法**

```
protoc -I ../../../../../. -I . --go-grpc_out=. --go_out=. *.proto
```

- **绝对路径写法**

```
protoc -I . -I %GOPATH%/src --go-grpc_out=. --go_out=. *.proto
```

### 注意点

- 命令中的参数

-I : 搜寻proto文件的来源目录

- win和 mac or linux的环境变量使用的写法不同

mac or linux :

```shell
$GOPATH
```

win：

```cmd
%GOPATH%
```

## 枚举类型

```protobuf
enum Gender{
	MALE = 0;
	FEMALE = 1;
}
//type Gender int32
//const(
//	Gender_MALE Gender = 0
//	Gender_FEMALE Gender = 0
//)
message Request{
	Gender g = 1;
}
```



## map类型

不建议

```
map<string,string> mp =4;
//map[string]string
```



## timeStamp

使用自带的google/protobuf/timestamp.proto

```
import "google/protobuf/timestamp.proto"
```



## metadata机制

以metadata形式传输map\[string\][]string类型，可用作传输header

- server

```go
type HelloServer struct{
	hello.UnimplementedHelloServer
}
//远端处理逻辑函数
func (s *HelloServer)Hello(ctx context.Context, req *hello.HelloRequest) (*hello.Response, error) {
	md, ok := metadata.FromIncomingContext(ctx)
	if ok{log.Println("failed to get metadata ")}
	if nameSlice,ok := md["name"]; ok{
		for i,v := range nameSlice{
			fmt.Printf("[%v] = %v\n ",i,v)
		}
	}

	for k,v := range md{
		fmt.Printf("metadata: key=%v, value=%v\n",k,v)
	}

	//返回值通过修改reply的值
	return &hello.Response{
		Reply: "Hello, "+req.Name+" Your age: "+strconv.Itoa(int(req.Age)),
	},nil
}

func main(){
	g := grpc.NewServer()
	hello.RegisterHelloServer(g, &HelloServer{})
	listener, err := net.Listen("tcp",":8887")
	if err != nil{
		panic("failed to listen:" + err.Error())
	}
	err = g.Serve(listener)
	if err != nil{
		panic("fail to start grpc:"+err.Error())
	}
}

```

- proto

```protobuf
syntax = "proto3";

option go_package="./;hello";

service Hello{
  rpc Hello(HelloRequest) returns (Response); //hello接口
}

message HelloRequest{
  string name = 1;//1是编号
  int32 age = 2;
  repeated string courses = 3;//类似数组
}

message Response{
  string reply = 1;
}

```

- client

```go

var client hello.HelloClient

func main() {
	conn, err := grpc.Dial(":8887", grpc.WithInsecure())
	if err != nil {
		panic("连接失败")
	}
	defer conn.Close()
	client = hello.NewHelloClient(conn)
	//md := metadata.Pairs("timestamp", time.Now().Format(time.Stamp))
	md := metadata.New(map[string]string{
		"name":"roger",
		"age":"112233",
	})
	ctx := metadata.NewOutgoingContext(context.Background(), md)
	rsp, err := client.Hello(ctx, &hello.HelloRequest{
		Name: "roger",
	})
	if err != nil {
		panic("调用失败")
	}
	fmt.Println(rsp.Reply)
}

```

## grpc拦截器

- server

  在grpc.NewServer()中签名可以带很多option，拦截器就是其中一种

  func **main**:

  ```
  	//需要实现一个函数
  	myInterceptor := func(ctx context.Context, req interface{},
  	info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (resp interface{}, err error){
  		log.Println("接收到一个新请求")
  		return handler(ctx, req)
  	}
  	opt := grpc.UnaryInterceptor(myInterceptor)
  ```

  

- client

  客户端的则设置在Dial函数中

  func **main**:

  ```go
  	clientInterceptor := func(ctx context.Context, method string, req, reply interface{}, cc *grpc.ClientConn, invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error{
  		start := time.Now()
  		err := invoker(ctx, method, req, reply, cc, opts...)//先不操作
  		log.Println("耗时：",time.Since(start))
  		return err
  	}
  	opt := grpc.WithUnaryInterceptor(clientInterceptor)//生成dial的配置
  	opts := []grpc.DialOption{//多个配置
  		grpc.WithInsecure(),
  		opt,
  	}
  	conn, err := grpc.Dial(":8887", opts...)
  ```
  

  [grpc中间件文档](https://github.com/grpc-ecosystem/go-grpc-middleware)

## grpc验证器

### 环境准备

- [安装](## grpc拦截器)

- 生成命令

```shell
protoc -I . -I %GOPATH%/src --go-grpc_out=. --go_out=. --validate_out="lang=go:." *.proto
```

- 直接在main中先判断

func **main**:

```
	p := new(hello.Person)
	err := p.Validate()
	if err != nil {
		log.Print(err)
	}
```

输出：

```
2022/02/23 12:11:26 invalid Person.Id: value must be greater than 999
```

### 实例

proto

```protobuf
syntax = "proto3";
option go_package="./;hello";

import "github.com/envoyproxy/protoc-gen-validate/validate/validate.proto";

service Greeter{
  rpc SayHello(Person)returns(Person);
}

message Person {
  uint64 id    = 1 [(validate.rules).uint64.gt    = 999];

  string email = 2 [(validate.rules).string.email = true];

  string mobile = 4 [(validate.rules).string = {
    pattern: "^1[345789]\\d{9}$",
  }];
}

```

client

```go
var client hello.GreeterClient

func main() {
	opts := []grpc.DialOption{//多个配置
		grpc.WithInsecure(),
	}
	conn, err := grpc.Dial(":8887", opts...)
	if err != nil {
		panic("连接失败")
	}
	defer conn.Close()
	client = hello.NewGreeterClient(conn)

	rsp, err := client.SayHello(context.Background(), &hello.Person{
		Id : 2001,
		Email : "12138@hei.com",
		Mobile : "13555555555",
	})
	if err != nil {
		log.Printf("client.SayHello err : %v",err)
	}
	fmt.Println(rsp)
}
```

server

```go
// Validator validate.pb.go中的对象实现该接口，任意对象都可验证
type Validator interface{
	Validate() error
}

type HelloServer struct{
	hello.UnimplementedGreeterServer
}

// SayHello 远端处理逻辑函数
func (s *HelloServer)SayHello(ctx context.Context, p *hello.Person) (*hello.Person,error) {
	return p,nil
}
func main(){
	serverInterceptor := func(ctx context.Context, req interface{},
	info *grpc.UnaryServerInfo, handler grpc.UnaryHandler) (resp interface{}, err error){
	//	继续处理请求
	//	（proto.Persion）可以满足person的验证，所有接口还有其他接口怎么办，鸭子类型直接代替所有对象
		if r,ok := req.(Validator); ok{
 			if err = r.Validate(); err != nil{
				return nil , status.Error(codes.InvalidArgument, err.Error())
			}
		}
		return handler(ctx, req)
	}

	opt := grpc.UnaryInterceptor(serverInterceptor)
	g := grpc.NewServer(opt)
	hello.RegisterGreeterServer(g, &HelloServer{})
	listener, err := net.Listen("tcp",":8887")
	if err != nil{
		panic("failed to listen:" + err.Error())
	}
	err = g.Serve(listener)
	if err != nil{
		panic("fail to start grpc:"+err.Error())
	}
}
```

## grpc状态码

[官方文档](https://github.com/grpc/grpc/blob/master/doc/statuscodes.md)

## grpc错误处理

server

func [handler]函数中

```go
return nil,status.Errorf(codes.InvalidArgument, "invalid username %v", req.Name)
```

client

```go
if err != nil {
		st, ok := status.FromError(err)
		if !ok{
		//	不是status定义的error
			log.Fatalf("解析error失败，不是status的error，err : %v",err)
		}
		log.Println(st.Message())
		log.Println(st.Code())
	}
```

## 超时机制

server

```go
	time.Sleep(3*time.Second)
	return &hello.Response{
		Reply: "hello " + req.Name,
	},nil
```

client

```go
	//使用context
	ctx, _ := context.WithTimeout(context.Background(), time.Second*2)

	_, err = client.Hello(ctx, &hello.HelloRequest{
		Name: "roger",
		Age: 88,
	})

```

## protoc生成的源码

### server存根的生成

**server端帮我们生成接口，我们只需要去每个接口中实现对应的逻辑即可**

- proto

```protobuf
service Hello{
  rpc Hello(HelloRequest) returns (Response); //hello接口
}
```

- 模拟的存根

```go
type HelloServicer interface {
	// 实现了handler中NewHelloService的hello函数
	Hello(request string, reply *string) error
}

// ResgisterHelloService 如何做到和handler中对象的解耦？server关心的是函数->鸭子类型
//func ResgisterHelloService(srv handler.NewHelloService) {
//使用interface代替了这个对象
func ResgisterHelloService(srv HelloServicer) {
	rpc.RegisterName(handler.HelloServiceName, srv)
}
```

- grpc生成的存根

helloworld_grpc.pb.go

```go
...

type HelloServer interface {
	Hello(context.Context, *HelloRequest) (*Response, error)
	mustEmbedUnimplementedHelloServer()
}

...

func RegisterHelloServer(s grpc.ServiceRegistrar, srv HelloServer) {
	s.RegisterService(&Hello_ServiceDesc, srv)
}

...
```

### client存根的生成

**client端需要帮我们生成对应的方法，同时将这些方法都绑定到一个结构体上，生成的时候我们可能需要传参数，ip:port**

**java,python 构造函数 \_\_init\_\_:**

**go中是一个New初始化函数**

- 模拟的存根

```go
type HelloServiceStub struct {
	*rpc.Client
}

//在go中没有类，对象，就意味着没有初始化方法
func NewHelloServiceClient(protol, address string) HelloServiceStub {
	conn, err := rpc.Dial(protol, address)
	if err != nil {
		panic("connect fail")
	}
	return HelloServiceStub{conn}
}

func (c *HelloServiceStub) Hello(request string, reply *string) error {
	err := c.Call(handler.HelloServiceName+".Hello", request, &reply)
	return err
}
```

- grpc生成的存根

```go
type HelloClient interface {
	Hello(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption) (*Response, error)
}

type helloClient struct {
	cc grpc.ClientConnInterface
}

func NewHelloClient(cc grpc.ClientConnInterface) HelloClient {
	return &helloClient{cc}
}

func (c *helloClient) Hello(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := c.cc.Invoke(ctx, "/Hello/Hello", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}
```



# Micro&Micro-grpc

使用micro前注意事项👀

- micro分为v1,v2,v3,v4(latest)
- 确定项目使用的micro版本，安装以下工具包及插件
- 最重要的是，工具包和插件和代码中的依赖必须版本一致，如我接下来使用的micro的版本均为v3
- 由于遇到太多bug，这里环境配置在$GOPATH/bin中，将所有工具都按版本重命名

## 直接源码安装

- 没试过，可能会没有插件🤔

```
go get github.com/micro/micro/v3
```

## 分别安装micro&go-micro&protoc-gen-micro

### go-micro：微服务开发库，项目编写时导入的库

​		[下载地址](https://github.com/asim/go-micro)

​		[用例](https://github.com/go-micro-dev/examples)

### Micro：基于Go-micro开发的运行时工具集，生成项目代码

​		[下载地址](https://github.com/micro/micro/releases)

```
go install github.com/micro/micro/v3@latest
```

### proto-gen-micro：protoc的micro.pb的生成插件

​		[下载地址](https://github.com/go-micro-dev/protoc-gen-micro)

```
go install github.com/micro/micro/v3/cmd/protoc-gen-micro@master
```

## 工具生成命令

### MicroV1生成proto模板

#### 生成服务端

```
micro new --type srv go_code/gp/micro/testSrv
```

#### 生成客户端

```
micro new --type web go_code/gp/micro/testWeb
```

#### protoc-gen-micro生成micro.pb

```
protoc --go_out=. --micro_out=. ./*.proto
```

### MicroV2生成proto模板

#### 生成服务端

```
# 默认情况下Micro生成的代码会放到GOPATH/src中，通过配置--gopath=false可以选择在当前目录下
micro new testSrv
```

#### protoc-gen-micro生成micro.pb

makefile

```makefile
protoOutput=./proto/testSrv #相对的proto路径
.PHONY: proto
proto:
	protoc -I . --micro_out=$(ProtoOutput) --go_out=$(ProtoOutput) proto/testSrv/testSrv.proto
```

#### demo

##### service

handler

```go
type TestSrv struct{}

// Hello is a single request handler called via client.Call or the generated client code
func (e *TestSrv) Hello(ctx context.Context, req *testSrv.Request, rsp *testSrv.Response) error {
	log.Info("Received TestSrv.Call request")
	rsp.Msg = fmt.Sprintf("Hello %v, your age is %v, your charater is %v, your work is %v, have a good time\n",
		req.Name, req.Age, req.Role.Name, req.Role.Work)
	return nil
}
```

main

```go
func main() {
	/*---------------------更改注册中心-------------------*/
	//不使用则使用micro默认的mDNS注册中心

	//插件中注册consul的接口
	//reg := consul.NewRegistry()
	//插件中注册etcd的接口
	//reg := etcd.NewRegistry(
	//	registry.Addrs("http://127.0.0.1:2379"),
	//	)

	/*--------------------------------------------------*/
	//配置服务信息
	service := micro.NewService(
		micro.Name("testSrv"),
		//micro.Registry(reg),
		micro.Version("latest"),
		micro.Metadata(map[string]string{"protocol" : "http"}),
	)

	// 初始化服务
	service.Init()

	fmt.Println(service.Options())
	// 服务的处理逻辑
	testSrv.RegisterTestSrvHandler(service.Server(), new(handler.TestSrv))

	//Register Struct as Subscriber
	//micro.RegisterSubscriber("go.micro.service.testSrv", service.Server(), new(subscriber.TestSrv))

	// 运行
	if err := service.Run(); err != nil {
		log.Fatal(err)
	}
}
```

##### web

```go
//初始化micro
func InitMicro() client.Client{
	/*---------------------更改注册中心-------------------*/
	//不使用则使用micro默认的mDNS注册中心

	//插件中注册consul的接口
	//reg:=consul.NewRegistry()

	//插件中注册etcd的接口

	//reg := etcd.NewRegistry(
	//	registry.Addrs("http://127.0.0.1:2379"),
	//)
	/*--------------------------------------------------*/

	//配置注册consul的接口获取服务信息
	service := micro.NewService(
		//micro.Registry(reg),
		//micro.Metadata(map[string]string{"protocol" : "http"}),//客户端报错
		micro.HandleSignal(true),
	)
	//返回服务的client，调用service
	return service.Client()
}

func main(){
	serviceClient := InitMicro()

	//使用client获取指定服务，返回服务的接口
	testSrvService := testSrv.NewTestSrvService("testSrv", serviceClient)

	//request的信息
	role := testSrv.Character{
		Name: "Programmer",
		Work: "Typing Code",
	}
	rsp,err := testSrvService.Hello(context.TODO(), &testSrv.Request{Name:"Johnson",Age: 33, Role: &role})

	if err != nil {
		log.Fatalf("client.Hello err : %v", err)
	}
	fmt.Println(rsp.Msg)
}
```

##### 目前故障

```
auth no found
```

### MicroV3生成proto模板

#### 生成服务端

```
micro new testSrv
```

#### protoc-gen-micro生成micro.pb

```
protoc --go_out=. --micro_out=. ./*.proto
```

#### demo运行

运行服务
在探讨如何编写服务前，我们先来运行一个现有的服务，因为只需几个命令即可！

首先，我们必须启动 micro server. 命令如下:

```shell
$ micro server
```

在与 micro server 交互之前，我们需要使用 id 为 ‘admin’ 和密码为 ‘micro’ 的账号进行登录:

```shell
$ micro login
Enter username: admin
Enter password:
Successfully logged in.
```

如果没什么意外的话你会看到列出了上述命令启动的一些服务。这里只是为了验证下一切是否正常，我们来看看哪些服务正在运行:

```shell
$ micro services
api
auth
broker
config
network
proxy
registry
runtime
server
store
```

#### 登录web

```url
localhost:8082/login
默认用户和密码 admin micro
```

![image-20220302142400485](http://myimg.go2flare.xyz/img/image-20220302142400485.png)

#### demo

##### service

handler

```go
type TestSrv struct{}

// Call is a single request handler called via client.Call or the generated client code
func (e *TestSrv) Hello(ctx context.Context, req *testSrv.Request, rsp *testSrv.Response) error {
	log.Info("Received TestSrv.Call request")
	rsp.Msg = fmt.Sprintf("Hello %v, your age is %v, your charater is %v, your work is %v, have a good time\n",
		req.Name, req.Age, req.Role.Name, req.Role.Work)
	return nil
}
```

main

```go
func main() {
	// Create service
	srv := service.New(
		service.Metadata(map[string]string{"protocol" : "http"}),//客户端报错
		service.Name("testsrv"),
		service.Version("latest"),
	)
	fmt.Println(srv.Options(),srv.Client().Options())

	// Register handler
	pb.RegisterTestSrvHandler(srv.Server(), new(handler.TestSrv))

	// Run service
	if err := srv.Run(); err != nil {
		logger.Fatal(err)
	}
}
```

注册服务到server

```shell
./testsrv.exe --proxy_address=127.0.0.1:8081 --auth_id admin --auth_secret micro

2022-03-02 14:55:52  file=grpc/grpc.go:998 level=info Server [grpc] Listening on [::]:50099
2022-03-02 14:55:52  file=grpc/grpc.go:828 level=info Registry [service] Registering node: testsrv-7e3af563-7c5b-46ae-a161-9c13e06cfd09
2022-03-02 15:18:36  file=handler/testSrv.go:16 level=info Received TestSrv.Call request
2022-03-02 15:19:05  file=handler/testSrv.go:16 level=info Received TestSrv.Call request

```

web

```go
//初始化micro
func InitMicro() client.Client{
	//配置注册consul的接口获取服务信息
	service := service.New(
		service.Metadata(map[string]string{"protocol" : "http"}),//客户端报错
		service.Name("testsrv"),
		service.Version("latest"),
	)
	//返回服务的client，调用service
	return service.Client()
}
```

### asim/MicroV3

需要用其他注册中心的时候，可以选这个版本



## Micro工具集组件

　　A、API：将http请求转向内部应用

　　　　1、API：将http请求映射到API接口

　　　　2、RPC：将http请求映射到RPC服务

　　　　3、event：将http请求广播到订阅者

　　　　4、proxy：反向代理

　　　　5、web：支持websocket反向代理

　　B、Web：web反向代理与管理控制

　　C、Proxy：代理风格的请求，支持异构系统只需要瘦客户端便可调用Micro服务

　　　　1. 注意：与Micro API不同，Proxy只处理micro风格的RPC请求，而非http请求

　　D、Cli：以命令行操控Micro服务

　　E、Bot：与常见的通信软件对接，负责传递消息，远程指令操作

三、Go-micro框架模块

　　![img](https://img2018.cnblogs.com/i-beta/1653159/202001/1653159-20200109142145453-675386528.png)

　　A、service：具体实例化的服务，包含两个重要组件：Client、Server

　　　　Client：发送RPC请求与广播消息

　　　　Server: 接收RPC请求与消费消息

　　B、Broker：异步通信组件

　　C、Codec：数据编码组件

　　D、Registry：服务注册组件

　　E、Selector：客户端均衡器

　　F、Transport：同步通信组件

四、Broker异步消息组件

　　![img](https://img2018.cnblogs.com/i-beta/1653159/202001/1653159-20200109143549217-753159534.png)

　　A、Subscribe：注册关心的主题（Topic)，指定队列（queue）发送消息

　　B、Publish：异步将消息推送到主题（Topic）

　　C、Encoding：编码消息（默认JSON格式）

五、Registry注册组件

　　![img](https://img2018.cnblogs.com/i-beta/1653159/202001/1653159-20200109143905598-779820906.png)

 

　　A、注册类型

　　　　1. 基于通用型注册中心，如Etcd、Consul、Zookeeper、Eureka

　　　　2. 基于网络广播，如mDNS、Gossip

            　　　　3. 基于消息中间件，如NATS

六、selector选择器组件

　　![img](https://img2018.cnblogs.com/i-beta/1653159/202001/1653159-20200109144949032-1997389570.png)

 

　　A、目前支持两种算法：随机和轮询

七、Transport同步请求组件

　　A、![img](https://img2018.cnblogs.com/i-beta/1653159/202001/1653159-20200109145134912-176136797.png)