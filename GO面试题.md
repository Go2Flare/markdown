> **golang面试题**

# 并发相关

## Golang中除了加Mutex锁以外还有哪些方式安全读写共享变量。

```
Golang中Goroutine 可以通过 Channel 进行安全读写共享变量，还可以通过原子性操作进行
```

## 无缓冲Chan的发送和接收是否同步

### 首先了解一下什么是缓冲

A := make(chan int) //无缓冲
B := make(chan int,1)//有缓冲
//A <- 1,这时候往A中写入1，一定会有<- A,只有这样其他值写入A的时候才可以进行下去，不然会阻塞。
//B <- 1,则不会发生阻塞，因为B的缓冲大小为1，只有当第二个值写入B时，第一个值还未被取出才会阻塞。

### 无缓冲通道

指在接收前没有能力保存任何值的通道。这种类型的通道要求发送goroutine和接收goroutine同时准备好，才能完成发送和接收操作。如果两个goroutine没有同时准备好，通道会导致先执行发送或接收操作的goroutine阻塞等待。这种对通道进行发送和接收的交互行为本身就是同步的，其中任意一个操作都无法离开另一个操作单独存在。

### 有缓冲通道

指通道可以保存多个值。如果给定了一个缓冲区容量，那么通道就是异步的，只要缓冲区有未使用空间用于发送数据，或还包含可以接收的数据，那么其通信就会无阻塞地进行。

所以，无缓冲Chan的发送和接收是同步的。

# 基础问题

## Golang 使用什么数据类型

Method （方法）、Bool（布尔） 、String（字符串） 、Array（数组） 、Slice（切片） 、Struct（结构体） 、Pointer（指针） 、Function（函数） 、Interface（接口） 、Map（哈希）、Channel（管道）

## 什么是 Goroutine？你如何停止它？

一个 Goroutine 是一个函数或方法执行同时旁边其他任何够程采用了特殊的Goroutine 线程。Goroutine 线程比标准线程更轻量级，大多数 Golang程序同时使用数千个Goroutine。

要创建 Goroutine，请 go 在函数声明之前添加关键字。 

您可以通过向 Goroutine 发送一个信号通道来停止它。Goroutines 只能在被告知检查时响应信号，因此您需要在逻辑位置（例如 for 循环顶部）包含检查。 

## Go 两个接口之间可以存在什么关系？

如果两个接口有相同的方法列表，那么他们就是等价的，可以相互赋值。如果接口 A 的方法列表是接口 B 的方法列表的自己，那么接口 B 可以赋值给接口A。接口查询是否成功，要在运行期才能够确定。

## Go 当中同步锁有什么特点？作用是什么

当一个 Goroutine（协程）获得了 Mutex 后，其他 Goroutine（协程）就只能乖乖的等待，除非该Goroutine 释放了该 Mutex。RWMutex 在读锁占用的情况下， 会阻止写，但不阻止读 RWMutex。 在写锁占用情况下，会阻止任何其他 Goroutine（无论读和写）进来，整个锁相当于由该 Goroutine 独占 
同步锁的作用是保证资源在使用时的独有性，不会因为并发而导致数据错乱， 保证系统的稳定性。

## Go 语言当中 Channel（通道）有什么特点，需要注意什么？

如果给一个 nil 的 channel 发送数据，会造成永远阻塞。 
如果从一个 nil 的 channel 中接收数据，也会造成永久阻塞。 
给一个已经关闭的 channel 发送数据， 会引起 panic。
从一个已经关闭的 channel 接收数据， 如果缓冲区中为空，则返回一个零值。

## Go 语言当中 Channel 缓冲有什么特点？

无缓冲的 channel 是同步的，而有缓冲的 channel 是非同步的。
无缓冲的通道只有当发送方和接收方都准备好时才会传送数据，否则准备好的一方将会被阻塞。
有缓存的channel区别在于只有当缓冲区被填满时，才会阻塞发送者，只有当缓冲区为空时才会阻塞接受者。

## Go 语言中 cap 函数可以作用于哪些内容？

array(数组)、 slice(切片)、 channel(通道)

## Go 语言当中 new 的作用是什么？

new 创建一个该类型的实例，并且返回指向该实例的指针。new 函数是内建函数。
函数定义： func new(Type) *Type 
使用 new 函数来分配空间。
传递给 new 函数的是一个类型，而不是一个值。
返回值是指向这个新分配的地址的指针。

## Go 语言中 make 的作用是什么？

make 的作用是为 slice, map or chan 的初始化 然后返回引用 make 函数是内建函数。
函数定义： func make(Type, size IntegerType) Type 
make(T, args)函数的目的和 new(T)不同仅仅用于创建 slice, map, channel 而且返回类型是实例

## Printf()，Sprintf()，FprintF() 都是格式化输出，有什么不同？

Printf 是标准输出，一般是屏幕，也可以重定向。 
Sprintf()是把格式化字符串输出到指定的字符串中。 
Fprintf()是把格式化字符串输出到文件中。

## Go 语言当中数组和切片的区别是什么？

**数组**： 
数组固定长度。数组长度是数组类型的一部分，所以[3]int 和[4]int 是两种不同的数组类型数组需要指定大小，不指定也会根据初始化，自动推算出大小，大小不可改变。数组是通过值传递的。

**切片**： 
切片可以改变长度。切片是轻量级的数据结构，三个属性，指针，长度，容量不需要指定大小**切片是地址传递**（引用传递）可以通过数组来初始化，也可以通过内置函数 **make()来初始化**，初始化的时len=cap，然后进行扩容。

## Go 语言当中数组和切片在传递的时候的区别是什么？

1. 数组是值传递 
2. 切片看上去像是引用传递，但其实是值传递，传递的是指针的值。

## Golang Slice 的底层实现

切片是基于数组实现的，它的底层是数组，它自己本身非常小，可以理解为对底层数组的引用。因为基于数组实现，所以它的底层的内存是连续分配的，效率非常高，还可以通过索引获得数据。

切片本身并不是动态数组或者数组指针。它内部实现的数据结构通过指针引用底层数组，设定相关属性将数据读写操作限定在指定的区域内。切片本身是一个只读对象，其工作机制类似数组指针的一种封装。 切片对象非常小，是因为它是只有 3 个字段的数据结构： 
1.**指向底层数组的指针**
2.**切片的长度** 
3.**切片的容量**

## Slice扩容原理

首先判断，如果新申请长度大于 2 倍的旧容量，那么最终容量就是新的切片长度 。
否则判断，如果旧切片的长度小于 1024，则最终容量就是旧容量的两倍。
否则判断，如果旧切片长度大于等于 1024，则最终容量从旧容量开始循环增加原来的 1/4, 直到最终容量大于等于新的切片长度。
如果最终容量计算值溢出，则最终容量就是新申请的长度。

扩容并不会改变原来的切片，而是会生成一个容量更大的切片，然后把原有的元素和新元素一并拷贝到新切片中。底层数组也会使用新的。

## Map的底层实现

Golang 中 map 的底层实现是一个**散列表**，因此实现 map 的过程实际上就是实现散表的过程。在这个散列表中，主要出现的结构体有两个，一个叫hmap(a header for a go map)，一个叫 bmap(a bucket for a Go map，通常叫其bucket)。

## 介绍一下channel

**一个通道相当于一个先进先出（FIFO）的队列。也就是说，通道中的各个元素值都是严格地按照发送的顺序排列的，先被发送通道的元素值一定会先被接收。元素值的发送和接收都需要用到操作符<-。我们也可以叫它接送操作符。一个左尖括号紧接着一个减号形象地代表了元素值的传输方向。**

Go 语言中，不共享内存来通信，而要通过通信来实现内存共享。Go 的**CSP(Communicating Sequential Process)并发模型**，中文可以叫做通信顺序进程，是通过 goroutine 和 channel 来实现的。 

channel 收发遵循先进先出 FIFO 的原则。分为有缓冲区和无缓冲区，channel中包括 buffer、sendx 和 recvx 收发的位置(ring buffer 记录实现)、sendq、recv。当 channel 因为缓冲区不足而阻塞了队列，则使用双向链表存储。

## Channel 的 ring buffer 实现

channel 中使用了 ring buffer（环形缓冲区) 来缓存写入的数据。ringbuffer 有很多好处，而且非常适合用来实现 FIFO 式的固定长度队列。

## 哪些无法被json包序列化

channel、func、complex不能被序列化。

## channel有几种类型

双向： var value chan int
单向只读：var value <-chan int
单向只写：var value chan <-int
单向一般用于**参数传递和返回值**

## 延迟函数是什么?

Go语言中有种不错的设计，即延迟（defer）语句，你可以在函数中添加多个defer语句。

当有多个defer语句是，我们可以将其看作是顺序压栈

当函数执行到最后时

1. 先执行return 后面返回值复制
2. defer栈出栈
3. return

特别是当你在进行一些打开资源的操作时，遇到错误需要提前返回，在返回前你需要关闭相应的资源，不然很容易造成资源泄露等问题。

注意:defer只会在当前函数结束时执行，循环或条件语句不适用

## select机制

golang 的 select 就是监听 IO 操作，当 IO 操作发生时，触发相应的动作。  
在执行select语句的时候，运行时系统会判断每个case中的发送或接收操作是否可以被**立即执行**(立即执行：意思是当前Goroutine不会因此操作而被阻塞) 
**select的用法与switch非常类似**，由select开始一个新的选择块，每个选择条件由case语句来描述。与switch语句可以选择任何可使用相等比较的条件相比，**select有比较多的限制**，其中最大的一条限制就是每个**case语句里必须是一个IO操作**，确切的说，应该是一个**面向channel的IO操作**。

**几个准则**：
●检查每个case语句
●如果有任意一个chan是send or recv read，那么就执行该block
●如果多个case是ready的，那么随机找1个并执行该block
●如果都没有ready，那么就block and wait
●如果有default block，而且其他的case都没有ready，就执行该default block

## 并发编程

1. 什么是Mutex，他的作用是什么？

最重要且最常用的同步工具当属**互斥量**（mutual exclusion，简称 mutex）。

一个互斥锁可以被用来保护一个临界区或者一组相关临界区。我们可以通过它来保证，在同一时刻只有一个 goroutine 处于该临界区之内。

2. 使用互斥锁的几种注意事项？

- 不要**重复锁定**互斥锁；
- 不要**忘记解锁**互斥锁，必要时使用defer语句；
- 不要对**尚未锁定或者已解锁**的互斥锁解锁；
- 不要在多个函数之间直接**传递互斥锁**。互斥锁属于值传递，把它传给一个函数、将它从函数中返回、把它赋给其他变量、让它进入某个通道都会导致它的副本的产生。如果真的要传，记得**传指针**进去。

**忘记解锁**还会使其他的 goroutine 无法进入到该互斥锁保护的临界区，这轻则会导致一些**程序功能的失效**，重则会造成**死锁和程序崩溃**。

3. Mutex 几种状态 

mutexLocked — 表示互斥锁的锁定状态； 
mutexWoken — 表示从正常模式被从唤醒； 
mutexStarving — 当前的互斥锁进入饥饿状态； 
waitersCount — 当前互斥锁上等待的 Goroutine 个数；

4. Mutex 正常模式和饥饿模式 

- 正常模式（非公平锁） 


正常模式下，所有等待锁的 goroutine 按照 FIFO（先进先出）顺序等待。唤醒的 goroutine 不会直接拥有锁，而是会和新请求 goroutine 竞争锁。新请求的goroutine 更容易抢占：因为它正在 CPU 上执行，所以刚刚唤醒的 goroutine有很大可能在锁竞争中失败。在这种情况下，这个被唤醒的 goroutine 会加入到等待队列的前面。 

- 饥饿模式（公平锁） 


为了解决了等待 goroutine 队列的**长尾问题饥饿模式**下，直接由 unlock 把锁交给等待队列中排在第一位的 goroutine (队头)，同时，饥饿模式下，新进来的 goroutine 不会参与抢锁也不会进入自旋状态，会直接进入等待队列的尾部。这样很好的解决了老的 goroutine 一直抢不到锁的场景。 

饥饿模式的触发条件：当一个 goroutine 等待锁时间超过 1 毫秒时，或者当前队列只剩下一个 goroutine 的时候，Mutex 切换到饥饿模式。 

总结 

对于两种模式，正常模式下的性能是最好的，goroutine 可以连续多次获取锁，饥饿模式解决了取锁公平的问题，但是性能会下降，这其实是性能和公平的一个平衡模式。

5. Mutex 允许自旋的条件 

- 锁已被占用，并且锁不处于饥饿模式。 
- 积累的自旋次数小于最大自旋次数（active_spin=4）。 
- CPU 核数大于 1。 
- 有空闲的 P。 
- 当前 Goroutine 所挂载的 P 下，本地待运行队列为空。

6. 读写锁是什么？

读写锁是读 / 写互斥锁的简称。在 Go 语言中，读写锁由sync.RWMutex类型的值代表。

顾名思义，读写锁是把对共享资源的“读操作”和“写操作”区别对待了。它可以对这两种操作施加不同程度的保护。换句话说，相比于互斥锁，读写锁可以实现更加细腻的访问控制。

一个读写锁中实际上包含了两个锁，即：读锁和写锁。sync.RWMutex类型中的Lock方法和Unlock方法分别用于对写锁进行锁定和解锁，而它的RLock方法和RUnlock方法则分别用于对读锁进行锁定和解锁。

7. RWMutex 注意事项 

- RWMutex 是单写多读锁，该锁可以加多个读锁或者一个写锁。
- 读锁占用的情况下会阻止写，不会阻止读，多个 Goroutine 可以同时获取读锁。
- 写锁会阻止其他 Goroutine（无论读和写）进来，整个锁由该 Goroutine 独占。
- 适用于读多写少的场景。
- RWMutex 类型变量的零值是一个未锁定状态的互斥锁 。
- RWMutex 在首次被使用之后就不能再被拷贝。
- RWMutex 的读锁或写锁在未锁定状态，解锁操作都会引发 panic。
- RWMutex 的一个写锁去锁定临界区的共享资源，如果临界区的共享资源已被（读锁或写锁）锁定，这个写锁操作的 goroutine 将被阻塞直到解锁。
- RWMutex 的读锁不要用于递归调用，比较容易产生死锁。
- RWMutex 的锁定状态与特定的 goroutine 没有关联。一个 goroutine 可以 RLock（Lock），另一个 goroutine 可以 RUnlock（Unlock）。 
- 写锁被解锁后，所有因操作锁定读锁而被阻塞的 goroutine 会被唤醒，并都可以成功锁定读锁。
- 读锁被解锁后，在没有被其他读锁锁定的前提下，所有因操作锁定写锁而被阻塞的 Goroutine，其中等待时间最长的一个 Goroutine 会被唤醒。

6. Cond 是什么 

Cond 实现了一种**条件变量**，条件变量并不是被用来保护临界区和共享资源的，它是用于协调想要访问共享资源的那些线程的。当共享资源的状态发生变化时，它可以被用来通知被互斥锁阻塞的线程。

条件变量是基于互斥锁的，它必须有互斥锁的支撑才能够起作用。

条件变量提供的方法有三个：等待通知（wait）、单发通知（signal）和广播通知（broadcast）。

我们在利用条件变量等待通知的时候，需要在它基于的那个互斥锁保护下进行。而在进行单发通知或广播通知的时候，却是恰恰相反的，也就是说，需要在对应的互斥锁解锁之后再做这两种操作。

7. Broadcast 和 Signal 区别 

func (c *Cond) Broadcast() 
Broadcast 会唤醒**所有等待 c** 的 goroutine。 
调用 Broadcast 的时候，可以加锁，也可以不加锁。 

func (c *Cond) Signal() 
Signal 只唤醒 **1 个等待 c** 的 goroutine。 
调用 Signal 的时候，可以加锁，也可以不加锁。

我们最好在解锁条件变量基于的那个互斥锁之后，再去调用它的这两个方法。这更有利于程序的运行效率。

条件变量的Wait方法总会把当前的 goroutine 添加到通知队列的队尾，而它的Signal方法总会从通知队列的队首开始，查找可被唤醒的 goroutine。所以，因Signal方法的通知，而被唤醒的 goroutine 一般都是最早等待的那一个。

当通知被发送的时候，如果没有任何 goroutine 需要被唤醒，那么该通知就会立即失效。

8. Cond 中 Wait 使用 

func (c *Cond) Wait() 
Wait()会自动释放 c.L 锁，并挂起调用者的 goroutine。之后恢复执行， Wait()会在返回时对 c.L 加锁。 
除非被 Signal 或者 Broadcast 唤醒，否则 Wait()不会返回。 
由于 Wait()第一次恢复时，C.L 并没有加锁，所以当 Wait 返回时，调用者通常并不能假设条件为真。
取而代之的是, 调用者应该在循环中调用 Wait。（简单来说，只要想使用condition，就必须加锁。）
如果一个 goroutine 因收到通知而被唤醒，但却发现共享资源的状态，依然不符合它的要求，那么就应该再次调用条件变量的Wait方法，并继续等待下次通知的到来。

9. 什么操作叫做原子操作 

原子操作即是**进行过程中不能被中断的操作**，针对某个值的原子操作在被进行的过程中，CPU 绝不会再去进行其他的针对该值的操作。为了实现这样的严谨性，原子操作仅会由一个独立的 CPU 指令代表和完成。原子操作是**无锁的**，常常直接通过 CPU 指令直接实现。 事实上，其它同步技术的实现常常依赖于原子操作。

10. sync/atomic包中提供了几种原子操作？可操作的数据类型又有哪些？

sync/atomic包中的函数可以做的原子操作有：加法（add）、比较并交换（compare and swap，简称 CAS）、加载（load）、存储（store）和交换（swap）。

这些函数针对的数据类型并不多。但是，对这些类型中的每一个，sync/atomic包都会有一套函数给予支持。这些数据类型有：int32、int64、uint32、uint64、uintptr，以及unsafe包中的Pointer。不过，针对unsafe.Pointer类型，该包并未提供进行原子加法操作的函数。

此外，sync/atomic包还提供了一个名为Value的类型，它可以被用来存储任意类型的值。

10. 原子操作和锁的区别 

- 原子操作由底层硬件支持，而锁则由操作系统的调度器实现。 
- 锁应当用来保护一段逻辑，对于一个变量更新的保护。 
- 原子操作通常执行上会更有效率，并且更能利用计算机多核的优势，如果要更新的是一个复合对象，则应当使用 atomic.Value 封装好的实现。

11. 什么是 CAS 

CAS 的全称为 Compare And Swap，直译就是比较交换。是一条 CPU 的原子指令，其作用是让 CPU 先进行比较两个值是否相等，然后原子地更新某个位置的值，其实现方式是给予硬件平台的汇编指令，在 intel 的 CPU 中，使用的 cmpxchg 指令，就是说 CAS 是靠硬件实现的，从而在硬件层面提升效率。 

12. WaitGroup 用法 

sync.WaitGroup类型（以下简称WaitGroup类型）是开箱即用的，也是并发安全的。
WaitGroup类型拥有三个指针方法：Add、Done和Wait。你可以想象该类型中有一个计数器，它的默认值是0。我们可以通过调用该类型值的Add方法来增加，或者减少这个计数器的值。

一个 WaitGroup 对象可以等待一组协程结束。使用方法是： 
1
main 协程通过调用 wg.Add(delta int) 设置 worker 协程的个数，然后创建 worker 协程； 
2
worker 协程执行结束以后，都要调用 wg.Done()； 
3
main 协程调用 wg.Wait() 且被 block，直到所有 worker 协程全部执行结束 
4
后返回。 

13. WaitGroup 实现原理 

●
WaitGroup 主要维护了 2 个计数器，一个是请求计数器 v，一个是等待计数器 w，二者组成一个 64bit 的值，请求计数器占高 32bit，等待计数器占低32bit。 
●
每次 Add 执行，请求计数器 v 加 1，Done 方法执行，等待计数器减 1，v 为0 时通过信号量唤醒 Wait()。

14. 什么是 sync.Once 

Once 可以用来执行且仅仅执行一次动作，常常用于单例对象的初始化场景。 
Once 常常用来初始化单例资源，或者并发访问只需初始化一次的共享资源，或者在测试的时候初始化一次测试资源。
sync.Once 只暴露了一个方法 Do，你可以多次调用 Do 方法，但是只有第一次调用 Do 方法时 f 参数才会执行，这里的 f 是一个无参数无返回值的函数。
Once类型的Do方法只接受一个参数，这个参数的类型必须是func()，即：无参数声明和结果声明的函数。
只要传入某个Do方法的参数函数没有结束执行，任何之后调用该方法的 goroutine 就都会被阻塞。只有在这个参数函数执行结束以后，那些 goroutine 才会逐一被唤醒。

15. 什么是context类型

context.Context类型（以下简称Context类型）是在 Go 1.7 发布时才被加入到标准库的。

更具体地说，Context类型可以提供一类代表上下文的值。此类值是并发安全的，也就是说它可以被传播给多个 goroutine。

Context类型的值（以下简称Context值）是可以繁衍的，这意味着我们可以通过一个Context值产生出任意个子值。这些子值可以携带其父值的属性和数据，也可以响应我们通过其父值传达的信号。

正因为如此，所有的Context值共同构成了一颗代表了上下文全貌的树形结构。这棵树的树根（或者称上下文根节点）是一个已经在context包中预定义好的Context值，它是全局唯一的。通过调用context.Background函数，我们就可以获取到它。

这里注意一下，这个上下文根节点仅仅是一个最基本的支点，它不提供任何额外的功能。也就是说，它既不可以被撤销（cancel），也不能携带任何数据。

Context类型的实际值大体上分为三种，即：根Context值、可撤销的Context值和含数据的Context值。所有的Context值共同构成了一颗上下文树。这棵树的作用域是全局的，而根Context值就是这棵树的根。它是全局唯一的，并且不提供任何额外的功能。

16. context类型包含哪些with函数？

context包中还包含了四个用于繁衍Context值的函数，即：WithCancel、WithDeadline、WithTimeout和WithValue。

这些函数的第一个参数的类型都是context.Context，而名称都为parent。顾名思义，这个位置上的参数对应的都是它们将会产生的Context值的父值。

WithCancel函数用于产生一个可撤销的parent的子值。在coordinateWithContext函数中，我通过调用该函数，获得了一个衍生自上下文根节点的Context值，和一个用于触发撤销信号的函数。
withCancel
Go
复制代码

1
﻿
func gen(ctx context.Context) <-chan int {
2
﻿
    dst := make(chan int)
3
﻿
    n := 1
4
﻿
    go func() {
5
﻿
        for {
6
﻿
            select {
7
﻿
                case <-ctx.Done():
8
﻿
                return // return结束该goroutine，防止泄露
9
﻿
                case dst <- n:
10
﻿
                n++
11
﻿
            }
12
﻿
        }
13
﻿
    }()
14
﻿
    return dst
15
﻿
}
16
﻿
func main() {
17
﻿
    ctx, cancel := context.WithCancel(context.Background())
18
﻿
    defer cancel() // 当我们取完需要的整数后调用cancel
19
﻿
    
20
﻿
    for n := range gen(ctx) {
21
﻿
        fmt.Println(n)
22
﻿
        if n == 5 {
            break
        }
    }

}

而WithDeadline函数和WithTimeout函数则都可以被用来产生一个会定时撤销的parent的子值。
withDeadLine
Go
复制代码

1
﻿
func main() {
2
﻿
    d := time.Now().Add(50 * time.Millisecond)
3
﻿
    ctx, cancel := context.WithDeadline(context.Background(), d)
4
﻿

5
﻿
    // 尽管ctx会过期，但在任何情况下调用它的cancel函数都是很好的实践。
6
﻿
    // 如果不这样做，可能会使上下文及其父类存活的时间超过必要的时间。
7
﻿
    defer cancel()
8
﻿

9
﻿
    select {
10
﻿
    case <-time.After(1 * time.Second):
11
﻿
        fmt.Println("overslept")
12
﻿
    case <-ctx.Done():
13
﻿
        fmt.Println(ctx.Err())
14
﻿
    }
15
﻿
}
withTimeOut
Go
复制代码

1
﻿
package main
2
﻿

3
﻿
import (
4
﻿
    "context"
5
﻿
    "fmt"
6
﻿
    "sync"
7
﻿

8
﻿
    "time"
9
﻿
)
10
﻿

11
﻿
// context.WithTimeout
12
﻿

13
﻿
var wg sync.WaitGroup
14
﻿

15
﻿
func worker(ctx context.Context) {
16
﻿
LOOP:
17
﻿
    for {
18
﻿
        fmt.Println("db connecting ...")
19
﻿
        time.Sleep(time.Millisecond * 10) // 假设正常连接数据库耗时10毫秒
20
﻿
        select {
21
﻿
        case <-ctx.Done(): // 50毫秒后自动调用
22
﻿
            break LOOP
23
﻿
        default:
24
﻿
        }
25
﻿
    }
26
﻿
    fmt.Println("worker done!")
27
﻿
    wg.Done()
28
﻿
}
29
﻿

30
﻿
func main() {
31
﻿
    // 设置一个50毫秒的超时
32
﻿
    ctx, cancel := context.WithTimeout(context.Background(), time.Millisecond*50)
33
﻿
    wg.Add(1)
34
﻿
    go worker(ctx)
35
﻿
    time.Sleep(time.Second * 5)
36
﻿
    cancel() // 通知子goroutine结束
37
﻿
    wg.Wait()
38
﻿
    fmt.Println("over")
39
﻿
}

WithValue函数和取消Context无关，它是为了生成一个绑定了一个键值对数据的Context，这个绑定的数据可以通过Context.Value方法访问到。

17. sync.Pool 有什么用 

sync.Pool类型可以被称为临时对象池，它的值可以被用来存储临时的对象。
对于很多需要重复分配、回收内存的地方，sync.Pool 是一个很好的选择。频繁地分配、回收内存会给 GC 带来一定的负担，严重的时候会引起 CPU 的毛刺。而 sync.Pool 可以将暂时将不用的对象缓存起来，待下次需要的时候直接使用，不用再次经过内存分配，复用对象的内存，减轻 GC 的压力，提升系统的性能。
因此，临时对象池非常适合用作针对某种数据的缓存。从某种角度讲，临时对象池可以帮助程序实现可伸缩性，这也正是它的最大价值。

18. sync.Map 有什么用 

sync.Map类型，它是一种并发安全的字典。它提供了一些常用的键、值存取操作方法，并保证了这些操作的并发安全。同时，它还保证了存、取、删等操作的常数级执行时间。

与原生的字典相同，并发安全字典对键的类型也是有要求的。它们同样不能是函数类型、字典类型和切片类型。

另外，由于并发安全字典提供的方法涉及的键和值的类型都是interface{}，所以我们在调用这些方法的时候，往往还需要对键和值的实际类型进行检查。

19.  go有哪些是非线程安全的？ 

slice和map都是非线程安全的。

如何保证slice是线程安全的三种方式：
1.加锁
加锁方式保证线程安全
Go
复制代码

1
﻿
    s := []int{}
2
﻿
    var l sync.Mutex
3
﻿
    for i := 0; i < 100; i++ {
4
﻿
        a := i
5
﻿
        go func(i int) {
6
﻿
            l.Lock()
7
﻿
            s = append(s, i)
8
﻿
            l.Unlock()
9
﻿
        }(a)
10
﻿
    }
11
﻿
    time.Sleep(1 * time.Second)
12
﻿
    fmt.Println(len(s))
2.利用channel
利用channel实现
Go
复制代码

1
﻿
    num := 100
2
﻿
    var wg sync.WaitGroup
3
﻿
    wg.Add(num)
4
﻿
    nums := []int{}
5
﻿
    ch := make(chan int)
6
﻿
    for i := 0; i < num; i++ {
7
﻿
        a := i
8
﻿
        go func() {
9
﻿
            ch <- a
10
﻿
            wg.Done()
11
﻿
        }()
12
﻿
    }
13
﻿

14
﻿
    go func() {
15
﻿
        wg.Wait()
16
﻿
        close(ch)
17
﻿
    }()
18
﻿
    for i := range ch {
19
﻿
        nums = append(nums, i)
20
﻿
    }
3.利用索引更新值。要注意索引必须是局部变量。
利用索引保证并发安全。
Go
复制代码

1
﻿
s := make([]int, 100)
2
﻿
for i := 0; i < 100; i++ {
3
﻿
    a := i
4
﻿
    go func(i int) {
5
﻿
        s[i] = i + 1
6
﻿
    }(a)
7
﻿
}
8
﻿
time.Sleep(1 * time.Second)
9
﻿
fmt.Println(s)

20.  channel是如何关闭的？ 

如果channel c已经被关闭,继续往它发送数据会导致panic: send on closed channel。
但是从这个关闭的channel中不但可以读取出已发送的数据，还可以不断的读取零值。
但是如果通过range读取，channel关闭后for循环会跳出。
通过i, ok := <-c可以查看Channel的状态，判断值是零值还是正常读取的值。

21. channel 有几种状态？

1
nil，未初始化的状态，只进行了声明，或者手动赋值为nil
2
active，正常的channel，可读或者可写
3
closed，已关闭，千万不要误认为关闭channel后，channel的值是nil
4
NIL的CHANNEL正常CHANNEL操作已关闭CHANNEL读到零值成功或阻塞阻塞<-CH成功或阻塞CH阻塞PANICCLOSE(CH)成功PANICPANIC




3. Go RUNTIME

1. Goroutine 定义 

Golang 在语言级别支持协程，称之为 Goroutine。Golang 标准库提供的所有系统调用操作(包括所有的同步 I/O 操作)，都会出让 CPU 给其他Goroutine。这让 Goroutine 的切换管理不依赖于系统的线程和进程，也不依赖于 CPU 的核心数量，而是交给 Golang 的运行时统一调度。 

2. GMP 指的是什么 

G（Goroutine）：我们所说的协程，为用户级的轻量级线程，每个 Goroutine对象中的 sched 保存着其上下文信息。
M（Machine）：对内核级线程的封装，数量对应真实的 CPU 数（真正干活的对象）。 所有的G都要放在M上才能运行。
P（Processor）：即为 G 和 M 的调度对象，用来调度 G 和 M 之间的关联关系，其数量可通过 GOMAXPROCS()来设置，默认为核心数。 

3. 1.0 之前 GM 调度模型 

调度器把 G 都分配到 M 上，不同的 G 在不同的 M 并发运行时，都需要向系统申请资源，比如堆栈内存等，因为资源是全局的，就会因为资源竞争照成很多性能损耗。为了解决这一的问题 go 从 1.1 版本引入，在运行时系统的时候加入 p对象，让 P 去管理这个 G 对象，M 想要运行 G，必须绑定 P，才能运行 P 所管理的 G。 

GM 调度存在的问题： 
1．单一全局互斥锁（Sched.Lock）和集中状态存储 
2．Goroutine 传递问题（M 经常在 M 之间传递”可运行”的 goroutine） 
3．每个 M 做内存缓存，导致内存占用过高，数据局部性较差 
4．频繁 syscall 调用，导致严重的线程阻塞/解锁，加剧额外的性能损耗。

4. GMP 调度流程 

全局队列2.1-局部已满则入队全局3.1-若M1的P本场队列为空从全局获取开始P的本地队列P的本地队列2~入周部队列1.创建体眠M队列GO FUNC05.3接管当前正在阳塞G的P3.2-看M1的P本地队列为空从其他的MP组合偷取G3-M使取G4调度S-执行5.1-者G.FUNO(发生SYSTEMCALL/阻塞G.FUNC()函数7-返园BY刘丹冰ACELD6销双G5.2创建一个M或从休眠队列取一个M



1
每个 P 有个局部队列，局部队列保存待执行的 goroutine（流程 2），当 M绑定的 P 的的局部队列已经满了之后就会把 goroutine 放到全局队列（流程 2-1） 
2
每个 P 和一个 M 绑定，M 是真正的执行 P 中 goroutine 的实体（流程 3），M 从绑定的 P 中的局部 队列获取 G 来执行。
3
当 M 绑定的 P 的局部队列为空时，M 会从全局队列获取到本地队列来执行 G（流程 3.1），当从全局队列中没有获取到可执行的 G 时候，M 会从其他 P 的局部队列中偷取 G 来执行（流程 3.2），这种从其他 P 偷的方式称为 work stealing 
4
当 G 因系统调用（syscall）阻塞时会阻塞 M，此时 P 会和 M 解绑即 handoff，并寻找新的 idle 的 M，若没有 idle 的 M 就会新建一个 M（流程 5.1） 
5
当 G 因 channel 或者 network I/O 阻塞时，不会阻塞 M，M 会寻找其他 runnable 的 G；当阻塞的 G 恢复后会重新进入 runnable 进入 P 队列等待执行（流程 5.3）

5. GMP 中 work stealing 机制 

获取 P 本地队列，当从绑定 P 本地 runq 上找不到可执行的 g，尝试从全局链表中拿，再拿不到从 netpoll 和事件池里拿，最后会从别的 P 里偷任务。P此时去唤醒一个 M。P 继续执行其它的程序。M 寻找是否有空闲的 P，如果有则将该 G 对象移动到它本身。接下来 M 执行一个调度循环（调用 G 对象->执行-> 
清理线程→继续找新的 Goroutine 执行） 

6. GMP 中 hand off 机制 

当本线程 M 因为 G 进行的系统调用阻塞时，线程释放绑定的 P，把 P 转移给其他空闲的 M 执行。 

当本线程M0因为G0进行系统调用阻塞时，线程释放绑定的P，把P转移给其他空闲的线程执行。进而某个空闲的M1获取P，继续执行P队列中剩下的G。而M0由于陷入系统调用而进被阻塞，M1接替M0的工作，只要P不空闲，就可以保证充分利用CPU。M1的来源有可能是M的缓存池，也可能是新建的。

7. 协作式的抢占式调度 

在 1.14 版本之前，程序只能依靠 Goroutine 主动让出 CPU 资源才能触发调度。这种方式存在问题有： 
1
某些 Goroutine 可以长时间占用线程，造成其它 Goroutine 的饥饿。 
2
垃圾回收需要暂停整个程序（Stop-the-world，STW），最长可能需要几分钟的时间，导致整个程序无法工作。

8. 基于信号的抢占式调度 

在Linux中这种真正的抢占式调度是基于信号完成的，所以也称为“异步抢占”。

●
M 注册一个 SIGURG 信号的处理函数：sighandler。
●
sysmon 线程检测到执行时间过长的 goroutine 或者GC stw 时，会向相应的 M（或者说线程，每个线程对应一个 M）发送 SIGURG 信号。
●
收到信号后，内核执行 sighandler 函数，通过 pushCall 插入 asyncPreempt 函数调用。
●
回到当前 goroutine 执行 asyncPreempt 函数，通过 mcall 切到 g0 栈执行 gopreempt_m。
●
将当前 goroutine 插入到全局可运行队列，M 则继续寻找其他 goroutine 来运行。
●
被抢占的 goroutine 再次调度过来执行时，会继续原来的执行流。








基于信号的抢占式调度，抢占也只会在垃圾回收扫描任务时触发。

9. GMP 调度过程中存在哪些阻塞 

●
I/O，select   IO阻塞
●
block on syscall  系统调用阻塞
●
channel 	管道堵塞 
●
等待锁 	等待锁
●
runtime.Gosched()  

10. Sysmon 有什么作用 

Sysmon 也叫监控线程，变动的周期性检查，好处 
1
释放闲置超过 5 分钟的 span 物理内存； 
2
如果超过 2 分钟没有垃圾回收，强制执行； 
3
将长时间未处理的 netpoll 添加到全局队列；
4
向长时间运行的 G 任务发出抢占调度（超过 10ms 的 g，会进行retake）； 
5
收回因 syscall 长时间阻塞的 P； 

11. 三色标记原理 

我们首先看一张图，大概就会对 三色标记法有一个大致的了解： 
BWHITEROOT SETABDACHFEGDGREYEBLACK


原理：

1
首先把所有的对象都放到白色的集合中 
2
从根节点开始遍历对象，遍历到的白色对象从白色集合中放到灰色集合中 
3
遍历灰色集合中的对象，把灰色对象引用的白色集合的对象放入到灰色集 合中，同时把遍历过的灰色集合中的对象放到黑色的集合中。
4
循环步骤 3，直灰色集合中没有对象。
5
步骤 4 结束后，白色集合中的对象就是不可达对象，也就是垃圾，进行回收。

12. 写屏障 


Go 在进行三色标记的时候并没有 STW，也就是说，此时的对象还是可以进行修改。 
ROOTAC


我们在进行三色标记中扫描灰色集合中，扫描到了对象 A，并标记了对象 A 的所有引用，这时候，开始扫描对象 D 的引用，而此时，另一个 goroutine 修改了 D->E 的引用，变成了如下图所示。
ROOTMCD


这样会不会导致 E 对象就扫描不到了，而被误认为为白色对象，也就是垃圾写屏障就是为了解决这样的问题，引入写屏障后，在上述步骤后，E 会被认为是存活的，即使后面 E 被 A 对象抛弃，E会被在下一轮的 GC 中进行回收，这一轮 GC 中是不会对对象 E 进行回收的。 

这是利用强三色不变性：黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象。如果A是黑色对象，E为白色对象，他会将E改为灰色对象。

因为栈上的对象在垃圾收集中也会被认为是根对象，所以为了保证内存的安全，Dijkstra 必须为栈上的对象增加写屏障或者在标记阶段完成重新对栈上的对象进行扫描，这两种方法各有各的缺点，前者会大幅度增加写入指针的额外开销，后者重新扫描栈对象时需要暂停程序，垃圾收集算法的设计者需要在这两者之间做出权衡。

13. 插入写屏障 

Go GC 在混合写屏障之前，一直是插入写屏障，由于栈赋值没有 hook 的原因，栈中没有启用写屏障，所以有 STW。Golang 的解决方法是：只是需要在结束时启动 STW 来重新扫描栈。这个自然就会导致整个进程的赋值器卡顿。

在标记阶段中，每次进行指针赋值操作时，都需要引入写屏障，这无疑会增加大量性能开销；为了避免造成性能问题，Go 团队在最终实现时，没有为所有栈上的指针写操作，启用写屏障，而是当发生栈上的写操作时，将栈标记为灰色，但此举产生了灰色赋值器，将会需要标记终止阶段 STW 时对这些栈进行重新扫描。

14. 删除写屏障 

删除屏障也是拦截写操作，因为它是写入一个空对象。具体的操作是，被删除的对象，如果自身为灰色或者白色，那么被标记为灰色。满足了弱三色不变式原则，保护灰色对象到白色对象的可达路径不会断。

看到最终结果可能不是大家所希望的，对象5已经被对象1删除了，为啥GC不把它清理呢？其实这样做是为了满足弱三色不变式原则，被删除对象都需要标记为灰色，假如对象4此时添加了对象5的引用，那么对象5就会被无辜删除了。那么对象5什么时候被删除呢？答案是等到下一轮GC，对象1肯定到达不了对象5，同时也没有从根节点出发的对象到达对象5，那么对象5就会被合法地删除。

我们可以看到删除写屏障的不足：回收精度低，一个对象即使被删除了最后一个指向它的指针，也依然可以活一轮GC，在下一轮GC中才被清除。






15. 混合写屏障 

在 v1.8 版本中，由插入写屏障和删除写屏障构成了如下所示的混合写屏障，其流程如下：
●
GC 开始，将栈上的全部可达对象标记为黑色，之后便不再需要进行重新扫描。
●
GC 期间，任何在栈上新创建的对象都标记为黑色。
●
写屏障将被删除的对象标记为灰色。
●
写屏障将新添加的对象标记为灰色。

1
混合写屏障继承了插入写屏障的优点，起始无需 STW 打快照，直接并发扫描垃圾即可； 
2
混合写屏障继承了删除写屏障的优点，赋值器是黑色赋值器，GC 期间，任何在栈上创建的新对象，均为黑色。扫描过一次就不需要扫描了，这样就消除了插入写屏障时期最后 STW 的重新扫描栈； 
3
混合写屏障扫描精度继承了删除写屏障，比插入写屏障更低，随着带来的是 GC 过程全程无 STW； 
4
混合写屏障扫描栈虽然没有 STW，但是扫描某一个具体的栈的时候，还是要停止这个 goroutine 赋值器的工作（针对一个 goroutine 栈来说，是暂停扫的，要么全灰，要么全黑哈，原子状态切换）。 

16. GC 触发时机 

主动触发：调用 runtime.GC
被动触发： 
1
使用系统监控(Sysmon )，该触发条件由 runtime.forcegcperiod 变量控制，默认为 2 分钟。当超过两分钟没有产生任何 GC 时，强制触发 GC。 
2
使用步调（Pacing）算法，其核心思想是控制内存增长的比例。如 Go 的 GC 是一种比例 GC, 下一次 GC 结束时的堆大小和上一次 GC 存活堆大小成比例。如果超过这个比例就会触发GC。

17. Go 语言中 GC 的流程是什么？ 

1
清理终止阶段；
a
暂停程序，所有的处理器在这时会进入安全点（Safe point）；
b
如果当前垃圾收集循环是强制触发的，我们还需要处理还未被清理的内存管理单元；
2
标记阶段；
a
将状态切换至 _GCmark、开启写屏障、用户程序协助（Mutator Assists）并将根对象入队；
b
恢复执行程序，标记进程和用于协助的用户程序会开始并发标记内存中的对象，写屏障会将被覆盖的指针和新指针都标记成灰色，而所有新创建的对象都会被直接标记成黑色；
c
开始扫描根对象，包括所有 Goroutine 的栈、全局对象以及不在堆中的运行时数据结构，扫描 Goroutine 栈期间会暂停当前处理器；
d
依次处理灰色队列中的对象，将对象标记成黑色并将它们指向的对象标记成灰色；
e
使用分布式的终止算法检查剩余的工作，发现标记阶段完成后进入标记终止阶段；
3
标记终止阶段；
a
暂停程序、将状态切换至 _GCmarktermination 并关闭辅助标记的用户程序；
b
清理处理器上的线程缓存；
4
清理阶段；
a
将状态切换至 _GCoff 开始清理阶段，初始化清理状态并关闭写屏障；
b
恢复用户程序，所有新创建的对象会标记成白色；
c
后台并发清理所有的内存管理单元，当 Goroutine 申请新的内存管理单元时就会触发清理；

18. GC 如何调优 

通过 go tool pprof 和 go tool trace 等工具 。

1
控制内存分配的速度，限制 Goroutine 的数量，从而提高赋值器对 CPU的利用率。 
2
减少并复用内存，例如使用 sync.Pool 来复用需要频繁创建临时对象，例如提前分配足够的内存来降低多余的拷贝。 
3
需要时，增大 GOGC 的值，降低 GC 的运行频率。