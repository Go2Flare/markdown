# 二叉树的种类

## 满二叉树

满⼆叉树：如果⼀棵⼆叉树只有度为0的结点和度为2的结点，并且度为0的结点在同⼀层上，则这棵⼆
叉树为满⼆叉树。
如图所示：

![image-20220314235330131](http://myimg.go2flare.xyz/img/image-20220314235330131.png)这棵⼆叉树为满⼆叉树，也可以说深度为k，有2^k-1个节点的⼆叉树  

完全⼆叉树
完全⼆叉树的定义如下：在完全⼆叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最⼤值，并且最下⾯⼀层的节点都集中在该层最左边的若⼲位置。若最底层为第 h 层，则该层包含 1~ 2^h -1个节点。

![image-20220315000306149](http://myimg.go2flare.xyz/img/image-20220315000306149.png)
我来举⼀个典型的例⼦如题：
相信不少同学最后⼀个⼆叉树是不是完全⼆叉树都中招了。
之前我们刚刚讲过优先级队列其实是⼀个堆，堆就是⼀棵完全⼆叉树，同时保证⽗⼦节点的顺序关系。
⼆叉搜索树
前⾯介绍的书，都没有数值的，⽽⼆叉搜索树是有数值的了， ⼆叉搜索树是⼀个有序树。
若它的左⼦树不空，则左⼦树上所有结点的值均⼩于它的根结点的值；
若它的右⼦树不空，则右⼦树上所有结点的值均⼤于它的根结点的值；
它的左、右⼦树也分别为⼆叉排序树
下⾯这两棵树都是搜索树  

![image-20220315003200091](http://myimg.go2flare.xyz/img/image-20220315003200091.png)

平衡⼆叉搜索树
平衡⼆叉搜索树：⼜被称为AVL（Adelson-Velsky and Landis）树，且具有以下性质：它是⼀棵空树或它的左右两个⼦树的⾼度差的绝对值不超过1，并且左右两个⼦树都是⼀棵平衡⼆叉树。
如图：
最后⼀棵 不是平衡⼆叉树，因为它的左右两个⼦树的⾼度差的绝对值超过了1。

![image-20220315000417244](http://myimg.go2flare.xyz/img/image-20220315000417244.png)

C++中map、 set、 multimap， multiset的底层实现都是平衡⼆叉搜索树，所以map、 set的增删操作
时间时间复杂度是logn，注意我这⾥没有说unordered_map、 unordered_set， unordered_map、
unordered_map底层实现是哈希表。
所以⼤家使⽤⾃⼰熟悉的编程语⾔写算法，⼀定要知道常⽤的容器底层都是如何实现的，最基本的就是
map、 set等等，否则⾃⼰写的代码，⾃⼰对其性能分析都分析不清楚！  

# 二叉树的存储方式

⼆叉树可以链式存储，也可以顺序存储。
那么链式存储⽅式就⽤指针， 顺序存储的⽅式就是⽤数组。
顾名思义就是顺序存储的元素在内存是连续分布的，⽽链式存储则是通过指针把分布在散落在各个地址
的节点串联⼀起。
链式存储如图：

![image-20220315003223655](http://myimg.go2flare.xyz/img/image-20220315003223655.png)链式存储是⼤家很熟悉的⼀种⽅式，那么我们来看看如何顺序存储呢？
其实就是⽤数组来存储⼆叉树，顺序存储的⽅式如图：

![image-20220315003300775](http://myimg.go2flare.xyz/img/image-20220315003300775.png)

⽤数组来存储⼆叉树如何遍历的呢？
如果⽗节点的数组下表是i，那么它的左孩⼦就是i * 2 + 1，右孩⼦就是 i * 2 + 2。
但是⽤链式表示的⼆叉树，更有利于我们理解，所以⼀般我们都是⽤链式存储⼆叉树。
所以⼤家要了解，⽤数组依然可以表示⼆叉树  

# 二叉树的遍历

关于⼆叉树的遍历⽅式，要知道⼆叉树遍历的基本⽅式都有哪些。

我这⾥把⼆叉树的⼏种遍历⽅式列出来，⼤家就可以⼀⼀串起来了。
⼆叉树主要有两种遍历⽅式：
\1. 深度优先遍历：先**往深⾛**，遇到**叶⼦节点**再往回⾛。
\2. ⼴度优先遍历：**⼀层⼀层**的去遍历。  

这两种遍历是图论中最基本的两种遍历⽅式，后⾯在介绍图论的时候 还会介绍到。
那么从深度优先遍历和⼴度优先遍历进⼀步拓展，才有如下遍历⽅式：

- 深度优先遍历
  前序遍历（递归法，迭代法）
  中序遍历（递归法，迭代法）
  后序遍历（递归法，迭代法）
- ⼴度优先遍历
  层次遍历（迭代法）  


这⾥前中后，其实指的就是中间节点的遍历顺序，只要⼤家记住 前中后序指的就是中间节点的位置就可
以了。
看如下中间节点的顺序，就可以发现，中间节点的顺序就是所谓的遍历⽅式
前序遍历：中左右
中序遍历：左中右
后序遍历：左右中  

![image-20220315003503352](http://myimg.go2flare.xyz/img/image-20220315003503352.png)

最后再说⼀说⼆叉树中深度优先和⼴度优先遍历实现⽅式，我们经常会使⽤递归的⽅式来实现深度优先遍历，也就是实现前中后序遍历，使⽤递归是⽐较⽅便的。
之前我们讲**栈与队列**的时候，就说过栈其实就是递归的⼀种是实现结构，也就说前中后序遍历的逻辑其实都是可以借助**栈使⽤⾮递归的⽅式来实现**的。
⽽⼴度优先遍历的实现⼀般使⽤队列来实现，这也是**队列先进先出**的特点所决定的，因为需要先进先出的结构，才能⼀层⼀层的来遍历⼆叉树。
这⾥其实我们⼜了解了栈与队列的⼀个应⽤场景了。
⼆叉树的定义
刚刚我们说过了⼆叉树有两种存储⽅式顺序存储，和链式存储，顺序存储就是⽤数组来存，这个定义没
啥可说的，我们来看看链式存储的⼆叉树节点的定义⽅式。

```go
type TreeNode struct{
	Val int
	Left *TreeNode
	Right *TreeNode
}
```

⼤家会发现⼆叉树的定义 和链表是差不多的，相对于链表 ，⼆叉树的节点⾥多了⼀个指针， 有两个指针，指向左右孩⼦.  

## 总结

⼆叉树是⼀种基础数据结构，在算法⾯试中都是常客，也是众多数据结构的基⽯。
本篇我们介绍了⼆叉树的种类、存储⽅式、遍历⽅式以及定义，⽐较全⾯的介绍了⼆叉树各个⽅⾯的重点，帮助⼤家扫⼀遍基础。

# ⼆叉树的递归遍历  

这⾥帮助⼤家确定下来递归算法的三个要素。 每次写递归，都按照这三要素来写，可以保证⼤家写出正
确的递归算法！

1. **确定递归函数的参数和返回值**：
   确定哪些**参数**是递归的过程中需要**处理**的，那么就在递归函数⾥加上这个参数， 并且还要明确每次**递归的返回值**是什么进⽽确定递归函数的返回类型。
2. **确定终⽌条件**：
   写完了递归算法, 运⾏的时候，经常会遇到**栈溢出的错误**，就是没写终⽌条件或者**终⽌条件写的不对**，操作系统也是⽤⼀个**栈**的结构来保存每⼀层递归的信息，如果递归没有终⽌，操作系统的内存栈必然就会溢出。
3. **确定单层递归的逻辑**：
   确定每⼀层递归需要处理的信息。在这⾥也就会重复调⽤⾃⼰来实现递归的过程。  

## 前中后遍历

### 递归

- 以前序遍历为例

1. 确定递归函数的参数和返回值：因为要打印出前序遍历节点的数值，所以参数⾥需要传⼊数组在放节点的数值，除了这⼀点就不需要在处理什么数据了也不需要有返回值，所以不用返回参数，代码如下：  

   ```go
   var dfs func(cur *TreeNode)
   dfs = func(cur *TreeNode)
   ```

2. 确定终⽌条件：在递归的过程中，如何算是递归结束了呢，当然是当前遍历的节点是空了，那么本层递归就要要结束了，所以如果当前遍历的这个节点是空，就直接return，代码如下：

   ```go
   if cur == nil{return}
   ```

3. 确定单层递归的逻辑：前序遍历是中左右的循序，所以在单层递归的逻辑，是要先取中节点的数值，代码如下：

   ```
   res = append(res, cur.Val) //中
   dfs(root.Left) //左
   dfs(root.Right) //右
   ```

   单层递归的逻辑就是按照中左右的顺序来处理的，这样⼆叉树的前序遍历，基本就写完了，在看⼀下完整代码 :

   ```go
   func preorderTraversal(root *TreeNode) (res []int) {
       var dfs func(root *TreeNode)
       dfs =func(root *TreeNode){
           if root == nil{return}
           res = append(res, root.Val)
           dfs(root.Left)
           dfs(root.Right)
       }
       dfs(root)
       return 
   }
   ```

   中序

   ```go
   func inorderTraversal(root *TreeNode) (res []int) {
       var dfs func(root *TreeNode)
       dfs = func(root *TreeNode){
           if root ==  nil{return}
           dfs(root.Left)
           res =append(res, root.Val)
           dfs(root.Right)
       }
       dfs(root)
       return
   }
   ```

   后序

   ```go
   func postorderTraversal(root *TreeNode) (res []int) {
       var dfs func(root *TreeNode)
       dfs = func(root *TreeNode){
           if root == nil{return }
           dfs(root.Left)
           dfs(root.Right)
           res =append(res, root.Val)
       }
       dfs(root)
       return
   }
   ```

   此时⼤家可以做⼀做leetcode上三道题⽬，分别是：
   144.⼆[叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)
   145.⼆[叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)
   94.⼆叉树的中序遍历

### 非递归

- 前序（前序栈的顺序：中右左）

  ```go
  //先root入栈，取出栈元素的右左节点
  func preorderTraversal1(root *TreeNode) (res []int) {
     stack := []*TreeNode{root}
     for len(stack) != 0 {
        node := stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        if node != nil {
           res = append(res, node.Val)
           stack = append(stack, node.Right)
           stack = append(stack, node.Left)
        }
        
     }
     return
  }
  ```

  统一法

  ```go
  func preorderTraversal(root *TreeNode) (res []int) {
      if root == nil{return nil}
      st := []*TreeNode{root}
      for len(st)>0{
          e := st[len(st)-1]
          if e != nil{//遍历到非标记
              st = st[:len(st)-1]
              // 中左右
              if e.Right != nil{st = append(st, e.Right)}//右
              if e.Left != nil{st = append(st, e.Left)}//左
              st = append(st, e, nil)//一个nil作为标记 //中
          }else{
              // 有标记的就是遍历顺序的 “中”
              e = st[len(st)-2]
              st = st[:len(st)-2]
              res =append(res, e.Val)
          }
      }
      return 
  }
  ```
  
  
  
- 后序（中左右再反转）

  ```go
  func postorderTraversal1(root *TreeNode) (res []int) {
     stack := []*TreeNode{root}
     for len(stack) != 0 {
        node := stack[len(stack)-1]
        stack = stack[:len(stack)-1]
        if node != nil {
           res = append(res, node.Val)
           stack = append(stack, node.Left)
           stack = append(stack, node.Right)
        }
     }
     i := 0
     for ; i < len(res)>>1; i++ {
        res[i], res[len(res)-1-i] = res[len(res)-1-i], res[i]
     }
     return res
  }
  ```

  统一法

  ```go
  func postorderTraversal(root *TreeNode) (res []int) {
      if root == nil{return nil}
      st := []*TreeNode{root}
      for len(st)>0{
          //栈顶  
          e := st[len(st)-1]
          if e != nil{
              st = st[:len(st)-1]
              st = append(st, e, nil)//中，加上一个空节点，作为标记
              if e.Right!=nil{st = append(st, e.Right)}//右
              if e.Left !=nil{st = append(st, e.Left)}//左
          }else{
              e = st[len(st)-2]
              st = st[:len(st)-2]
              res = append(res, e.Val)
          }
      }
      return 
  }
  ```

  

- 中序（for判断条件是或或或）

  ```go
  func inorderTraversal(root *TreeNode) (res []int) {
      st := []*TreeNode{}
      //排除空节点，空栈
      for root != nil || len(st)!=0{
        	//这个条件很巧，还带判断了叶子节点的孩子情况  
          if root != nil{
              st = append(st, root)//栈记录轨迹
              root = root.Left//优先探测左孩子
          }else{
            	//当前节点为空的，从轨迹中回溯节点，左中
              root = st[len(st)-1]
              st = st[:len(st)-1]
              res = append(res, root.Val)
              root = root.Right//探测右孩子
          }
      }
      return
  }
  ```

  统一法

  ```go
  func inorderTraversal(root *TreeNode) (res []int) {
      if root == nil{return nil}
      st := []*TreeNode{root}
      for len(st)>0{
          //栈顶  
          e := st[len(st)-1]
          if e != nil{
              st = st[:len(st)-1]
              if e.Right!=nil{st = append(st, e.Right)}//右
              st = append(st, e, nil)//中，加上一个空节点，作为标记
              if e.Left !=nil{st = append(st, e.Left)}//左
          }else{
              e = st[len(st)-2]
              st = st[:len(st)-2]
              res = append(res, e.Val)
          }
      }
      return 
  }
  ```

# 层序遍历

队列先进先出，符合一层层的遍历逻辑

**栈先进后出适合模拟深度优先遍历也就是递归的逻辑**

**层序遍历就是图论中的广度优先遍历**，只不过应用在二叉树上

![image-20220319212320823](http://myimg.go2flare.xyz/img/image-20220319212320823.png)

```go
func levelOrder(root *TreeNode) {
    if root == nil{return}
    q := []*TreeNode{root}
    for len(q)>0{
        //如果没有记录一层，那就是每pop一个节点就回到for
        //l := len(q)
        //for i:=0; i<l; i++{
            e := q[0]
            q = q[1:]
            if e.Left != nil{q = append(q, e.Left)}
            if e.Right != nil{q = append(q, e.Right)}
        //}
    }
    return
}
```

注意：

```
基本都需要判断root==nil的情况
```

```go
func levelOrder(root *TreeNode) {
    if root == nil{return}
    q := []*TreeNode{root}
    for len(q)>0{
        l := len(q)
        for i:=0; i<l; i++{
            e := q[0]
            q = q[1:]
            // 单层当前节点逻辑
            if e.Left != nil{q = append(q, e.Left)}
            if e.Right != nil{q = append(q, e.Right)}
        }
    }
    return
}
```

## [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

```go
func levelOrder(root *TreeNode) (res [][]int) {
    if root == nil{return [][]int{}}
    q := []*TreeNode{root}
    for len(q)>0{
        l := len(q)
        row := make([]int, 0)
        for i:=0; i<l; i++{
            e := q[0]
            q = q[1:]
            row = append(row, e.Val)
            if e.Left != nil{q = append(q, e.Left)}
            if e.Right != nil{q = append(q, e.Right)}
        }
        res = append(res, row)
    }
    return
}
```

## [107. 二叉树的层序遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)

```go
func levelOrderBottom(root *TreeNode) (res [][]int) {
    if root == nil {return [][]int{}}
    q := []*TreeNode{root}
    for len(q)>0{
        l := len(q)
        row := make([]int, 0)
        for i:=0; i<l; i++{
            e:=q[0]
            q=q[1:]
            row = append(row, e.Val)
            if e.Left != nil{q = append(q, e.Left)}
            if e.Right != nil{q = append(q, e.Right)}
        }
        res = append(res, row)
    }
    for i:=0; i<len(res)>>1; i++{
        res[i], res[len(res)-1-i] = res[len(res)-1-i], res[i]
    }
    return 
}
```

## [199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)

```go
func rightSideView(root *TreeNode) (res []int) {
    if root == nil{return []int{}}
    q := []*TreeNode{root}
    for len(q)>0 {
        l := len(q)
        for i:=0; i<l; i++{
            e:=q[0]
            q=q[1:]
            if i == l-1{res = append(res, e.Val)}
            if e.Left != nil{q =append(q, e.Left)}
            if e.Right != nil{q =append(q, e.Right)}
        }
    }
    return 
}
```

## [429. N 叉树的层序遍历](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/)

```go
func levelOrder(root *Node) (res [][]int) {
    if root == nil{return [][]int{}}
    q := []*Node{root}
    for len(q)>0{
        l := len(q)
        row := make([]int, 0)
        for i:=0; i<l; i++{
            e:=q[0]
            q=q[1:]
            row=append(row, e.Val)
            for i:=0; i<len(e.Children); i++{
                if e.Children != nil{
                    q =append(q, e.Children[i])
                }
            }
        }
        res = append(res, row)
    }
    return
}
```

## [637. 二叉树的层平均值](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/)

```go
func averageOfLevels(root *TreeNode) (res []float64) {
    if root ==nil{return []float64{}}
    q := []*TreeNode{root}
    for len(q)>0{
        l:=len(q)
        var sum float64
        for i:=0; i<l; i++{
            e := q[0]
            q = q[1:]
            sum += float64(e.Val)
            if e.Left!=nil{q=append(q, e.Left)}
            if e.Right!=nil{q=append(q, e.Right)}
        }
        res = append(res, sum/float64(l))
    }
    return
}
```

## [515. 在每个树行中找最大值](https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/)

```go
func largestValues(root *TreeNode) (res []int) {
    if root ==nil{return []int{}}
    q := []*TreeNode{root}
    for len(q)>0{
        l := len(q)
        maximum := q[0].Val
        for i:=0; i<l; i++{
            e := q[0]
            q = q[1:]
            if e.Val > maximum{maximum = e.Val}
            if e.Left != nil{q=append(q, e.Left)}
            if e.Right != nil{q=append(q, e.Right)}
        }
        res = append(res, maximum)
    }
    return
}
```

## [116. 填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

```go
func connect(root *Node) *Node {
	//层序中每层记录前一个节点
    if root == nil{return nil}
    q := []*Node{root}
    for len(q)>0{
        l := len(q)
        var pre *Node
        for i:=0; i<l; i++{
            e := q[0]
            q =q[1:]
            if i != 0{
                pre.Next = e
            }
            pre = e
            if e.Left!= nil{q=append(q, e.Left)}
            if e.Right!= nil{q=append(q, e.Right)}
        }
    }
    return root
}
```

# 二叉树属性

## [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)

- 递归

```go
func invertTree(root *TreeNode) *TreeNode {
    var dfs func(root *TreeNode)
    dfs = func(root *TreeNode){
        if root == nil{return}
        root.Left, root.Right = root.Right, root.Left
        dfs(root.Left)
        dfs(root.Right)
    }
    dfs(root)
    return root
}
```

- 非递归

```go
func invertTree(root *TreeNode) *TreeNode {
    return invertTree1(root)
    // return invertTree2(root)
}
func invertTree1(root *TreeNode) *TreeNode {
    if root == nil{return nil}
    st := []*TreeNode{root}
    for len(st)>0{
        e := st[len(st)-1]
        if e!= nil{
            st = st[:len(st)-1]
            if e.Right != nil{st = append(st, e.Right)}
            if e.Left != nil{st = append(st, e.Left)}
            st = append(st, e, nil)
        }else{
            e = st[len(st)-2]
            st = st[:len(st)-2]
            e.Left, e.Right = e.Right, e.Left
        }
    }
    return root
}
func invertTree2(root *TreeNode) *TreeNode {
    st := []*TreeNode{root}
    for len(st)>0{
        e := st[len(st)-1]
        st = st[:len(st)-1]
        if e!= nil{
            e.Left, e.Right = e.Right, e.Left
            st = append(st, e.Left)
            st = append(st, e.Right)
        }
    }
    return root
}
```

- 层序遍历

```go
func invertTree(root *TreeNode) *TreeNode {
    if root == nil{return root}
    q := []*TreeNode{root}
    for len(q)>0{
        l := len(q)
        for i:=0; i<l; i++{
            e := q[0]
            q =q[1:]
            e.Left, e.Right = e.Right, e.Left
            if e.Left != nil{q =append(q, e.Left)}
            if e.Right != nil{q =append(q, e.Right)}
        }
    }
    return root
}
```

## [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

```go 
func maxDepth(root *TreeNode) (res int) {
    if root == nil{return 0}
    return 1+max(maxDepth(root.Left), maxDepth(root.Right))
}
func max(a,b int)int{if a>b{return a}; return b}
```

## [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)

最小深度是从根节点到最近叶子节点的最短路径上的节点数量

- 递归

```go
func minDepth(root *TreeNode) int {
    if root == nil{return 0}
    // if root.Left==nil && root.Right ==nil{ //这里可以不判断
    //     return 1
    // }
    if root.Left==nil&& root.Right != nil{
        return 1+minDepth(root.Right)
    }
    if root.Left!=nil&& root.Right==nil{
        return 1+minDepth(root.Left)
    }
    return 1+min(minDepth(root.Left), minDepth(root.Right))
}

func min(a,b int)int{if a<b {return a}; return b}
```

- 非递归

```go
func minDepth(root *TreeNode) int{
    if root == nil{return 0}
    res := math.MaxInt64
    q := []*TreeNode{root}
    depth := 0
    for len(q)>0{
        l := len(q)
        depth++
        for i:=0; i<l; i++{
            e := q[0]
            q = q[1:]
            if e.Left == nil && e.Right == nil && depth<res{
                res = depth
            }
            if e.Left != nil{q = append(q, e.Left)} 
            if e.Right != nil{q = append(q, e.Right)} 
        }
    }
    return res
}
```

## [222. 完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)

可以看出如果整个树不是满⼆叉树，就递归其左右孩⼦，直到遇到满⼆叉树为⽌，⽤公式计算这个⼦树（满⼆叉树）的节点数量  

![image-20220315225604497](http://myimg.go2flare.xyz/img/image-20220315225604497.png)

```go
func countNodes(root *TreeNode) int {
    if root == nil{return 0}
    llen, rlen:= 0,0
    left, right := root.Left, root.Right
    for left!=nil{llen++;left = left.Left}
    for right!=nil{rlen++;right = right.Right}
    if llen == rlen{
        return 2<<llen-1
    }
    return 1+countNodes(root.Left)+countNodes(root.Right)
}
```

## [110. 平衡二叉树](https://leetcode-cn.com/problems/balanced-binary-tree/)

用例：

```
[1,2,2,3,null,null,3,4,null,null,4]
```

![image-20220315233814860](http://myimg.go2flare.xyz/img/image-20220315233814860.png)

```go
func isBalanced(root *TreeNode) bool {
    if root == nil{return true}
    return abs(Depth(root.Left)-Depth(root.Right))<=1&&isBalanced(root.Left)&&isBalanced(root.Right)
}
func Depth(root *TreeNode) int{
    if root == nil{return 0}
    return 1+max(Depth(root.Left), Depth(root.Right))
}
func max(a,b int)int{if a>b{return a};return b}
func abs(a int)int{if a<0{return -a};return a}
```

- 非递归

```go
func isBalanced(root *TreeNode) bool {
    if root == nil{return true}
    var getDepth func(root *TreeNode)int
    getDepth = func(root *TreeNode)int{
        if root == nil{return 0}
        return 1+max(getDepth(root.Left), getDepth(root.Right))
    }

    st := []*TreeNode{root}
    for len(st)>0{
        e := st[len(st)-1]
        st = st[:len(st)-1]
        if e != nil{
            if abs(getDepth(e.Left)-getDepth(e.Right))>1{
                return false
            }
            st = append(st, e.Right)
            st = append(st, e.Left)
        }
    }
    return true
}
func max(a,b int)int{if a>b{return a};return b}
func abs(a int)int{if a<0{return -a}; return a}
```

## [257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)

```go
func binaryTreePaths(root *TreeNode) (res []string) {
    var dfs func(root *TreeNode, path string)
    dfs = func(root *TreeNode, path string){
        if root ==nil {return}
        // fmt.Println(path)
        if root.Left == nil && root.Right == nil{
            res = append(res, path)
        }
        if root.Left != nil{dfs(root.Left, path+"->"+fmt.Sprintf("%v",root.Left.Val))}
        if root.Right != nil{dfs(root.Right, path+"->"+fmt.Sprintf("%v",root.Right.Val))}
    }
    dfs(root, fmt.Sprintf("%v", root.Val))
    return
}
```

- 非递归

```go
func binaryTreePaths(root *TreeNode) (res []string) {
    type pair struct{
        Node *TreeNode
        path string
    }
    st := []pair{{root, strconv.Itoa(root.Val)}}
    for len(st)>0{
        e := st[len(st)-1]
        st = st[:len(st)-1]
        if e.Node!= nil{
            if e.Node.Left== nil && e.Node.Right== nil{
                res =append(res, e.path)
            }
            if e.Node.Right != nil{st =append(st, pair{e.Node.Right, e.path+"->"+strconv.Itoa(e.Node.Right.Val)})}
            if e.Node.Left != nil{st =append(st, pair{e.Node.Left, e.path+"->"+strconv.Itoa(e.Node.Left.Val)})}
        }
    }
    return
}
```

## [404. 左叶子之和](https://leetcode-cn.com/problems/sum-of-left-leaves/)

```go
func sumOfLeftLeaves(root *TreeNode) (res int) {
    var dfs func(root *TreeNode)
    dfs = func(root *TreeNode){
        if root == nil{return}
        if root.Left!=nil && root.Left.Left == nil && root.Left.Right==nil{
            res += root.Left.Val
        }
        dfs(root.Left)
        dfs(root.Right)
    }
    dfs(root)
    return
}
```

## [513. 找树左下角的值](https://leetcode-cn.com/problems/find-bottom-left-tree-value/)

```go
func findBottomLeftValue(root *TreeNode) int{
    if root == nil{return 0}
    res := root.Val
    // d 度量最底层
    md := 0
    var dfs func(root *TreeNode, d int)
    dfs = func(root *TreeNode, d int){
        if root ==nil{return }
        // 前序遍历，一定会从最左开始
        if d>md{res=root.Val; md = d}
        if root.Left!= nil{dfs(root.Left, d+1)}
        if root.Right!=nil{dfs(root.Right, d+1)}
    }
    dfs(root, md)
    return res
}
```

```go
func findBottomLeftValue(root *TreeNode) int {
    res := root.Val
    maxDepth := 0
    var dfs func(cur *TreeNode, curDepth int) 
    dfs = func(cur *TreeNode, curDepth int){
        // 前序遍历特性，最左的一开始即可取，剩下的只要比较深度即可
        if cur.Left == nil && cur.Right == nil{
            if curDepth > maxDepth{
                maxDepth = curDepth
                res = cur.Val
            }
        }
        if cur.Left != nil{ dfs(cur.Left, curDepth+1)}
        if cur.Right != nil{ dfs(cur.Right, curDepth+1)}
    } 
    dfs(root, 0)
    return res
}
```

- 非递归

```go
func findBottomLeftValue(root *TreeNode) (res int) {
    if root ==nil{return 0}
    q := []*TreeNode{root}
    for len(q)>0{
        l := len(q)
        for i:=0; i<l; i++{
            e := q[0]
            q = q[1:]
            if i==0{res = e.Val}
            if e.Left!=nil{q=append(q, e.Left)}
            if e.Right!=nil{q=append(q, e.Right)}
        }
    }
    return
}
```

# 路径总和

是否有符合target的叶子情况作为返回的参数

```go
func hasPathSum(root *TreeNode, targetSum int) bool {
    if root ==nil {return false}
    if root.Left == nil&&root.Right==nil&&targetSum == root.Val{
        return true
    }
    return hasPathSum(root.Left, targetSum-root.Val)||hasPathSum(root.Right, targetSum-root.Val)
}
```

- 非递归

```go
func hasPathSum(root *TreeNode, targetSum int) bool {
    type pair struct{
        root *TreeNode
        leftover int
    }
    st := []pair{{root, targetSum}}
    for len(st)>0{
        e := st[len(st)-1]
        st = st[:len(st)-1]
        if e.root!=nil{
            if e.root.Left == nil&&e.root.Right == nil&&e.leftover == e.root.Val{
                return true
            }
            st = append(st, pair{e.root.Left, e.leftover-e.root.Val})
            st = append(st, pair{e.root.Right, e.leftover-e.root.Val})
        }
    }
    return false
}
```

## [113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)

```go
func pathSum(root *TreeNode, targetSum int) (res [][]int) {
    var dfs func(root *TreeNode, targetSum int, path []int)
    dfs = func(root *TreeNode, targetSum int, path []int){
        if root == nil{return}
        // 叶子
        if root.Left == nil&&root.Right == nil&&targetSum == root.Val{
            new:=append([]int{}, path...)//深拷贝问题
            res =append(res, append(new, root.Val))
            return
        }
        dfs(root.Left, targetSum-root.Val, append(path, root.Val))
        dfs(root.Right, targetSum-root.Val, append(path, root.Val))
    }
    dfs(root, targetSum, []int{})
    return 
}
```

- 非递归

```go
func pathSum(root *TreeNode, targetSum int) (res [][]int) {
    if root == nil{return [][]int{}}
    type pair struct{
        root *TreeNode
        targetSum int
        path []int
    }
    st := []pair{{root, targetSum, []int{}}}
    for len(st)>0{
        p := st[len(st)-1]
        st = st[:len(st)-1]
        e, targetSum, path := p.root, p.targetSum, p.path
        if e!= nil{
            if e.Left == nil&&e.Right==nil&&targetSum == e.Val{
                new := append([]int{}, path...)//深拷贝问题
                res = append(res, append(new, e.Val))
            }
            st = append(st, pair{e.Left, targetSum-e.Val, append(path, e.Val)})
            st = append(st, pair{e.Right, targetSum-e.Val, append(path, e.Val)})
        }
    }
    return
}
```

## [437. 路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/)

```go
func pathSum(root *TreeNode, targetSum int) int {
    if root == nil{return 0}
    var dfs func(root *TreeNode, targetSum int)(count int)
    dfs = func(root *TreeNode, targetSum int)(count int){
        if root == nil {return 0}
        if targetSum == 0{
            count++
        }
        if root.Left!=nil{
            count += dfs(root.Left, targetSum-root.Left.Val)
        }
        if root.Right!=nil{
            count += dfs(root.Right, targetSum-root.Right.Val)
        }
        return 
    }
    return dfs(root, targetSum-root.Val)+pathSum(root.Left, targetSum)+pathSum(root.Right, targetSum)
}
```

用例：

```
[5,4,8,11,null,13,4,7,2,null,null,5,1]
22
```

![image-20220316013928212](http://myimg.go2flare.xyz/img/image-20220316013928212.png)

# 构造修改二叉树

## [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

```go
func buildTree(preorder []int, inorder []int) *TreeNode {
    if len(preorder)<1{return nil}
    piv := preorder[0]
    i:=0
    for ; i<len(inorder)&&piv!=inorder[i];i++{}
    root := &TreeNode{piv,nil,nil}
    root.Left = buildTree(preorder[1:i+1], inorder[:i])
    root.Right = buildTree(preorder[i+1:], inorder[i+1:])
    return root
}
```

- 非递归

```go
func buildTree(preorder []int, inorder []int) *TreeNode {
    root := &TreeNode{preorder[0],nil,nil}
    st := []*TreeNode{root}
    index := 0
    for i:=1; i<len(preorder); i++{
        e := st[len(st)-1]
        preCur := preorder[i]
        if e.Val!=inorder[index]{
            // 前序的特性：可以直接构建左节点
            e.Left = &TreeNode{preCur, nil, nil}
            st = append(st, e.Left)
        }else{
            // 只判断栈顶元素
            for len(st)>0 && st[len(st)-1].Val == inorder[index] {
                e = st[len(st)-1]// 更新获取栈顶
                st = st[:len(st)-1]
                index++
            }
            e.Right = &TreeNode{preCur, nil, nil}
            st = append(st, e.Right)
        }
    }
    return root
}
```



## [106. 从中序与后序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

```go
func buildTree(inorder []int, postorder []int) *TreeNode {
    if len(postorder)<1{return nil}
    n := len(postorder)
    piv := postorder[n-1]
    i:=0
    for ;i<len(inorder)&&inorder[i]!=piv; i++{}
    root:=&TreeNode{piv,nil,nil}
    root.Left = buildTree(inorder[:i], postorder[:i])
    root.Right = buildTree(inorder[i+1:], postorder[i:n-1])
    return root
}
```

- 非递归

```go
func buildTree(inorder []int, postorder []int) *TreeNode {
    n := len(postorder)
    root := &TreeNode{postorder[n-1],nil,nil}
    st := []*TreeNode{root}
    // 从最后开始往前
    index := n-1
    for i:=n-2; i>=0; i--{
        e := st[len(st)-1]
        postCur := postorder[i]
        if e.Val != inorder[index]{
            e.Right = &TreeNode{postCur, nil, nil}
            st =append(st, e.Right)
        }else{
            // 中序要从后面开始比较
            for len(st)>0 && st[len(st)-1].Val == inorder[index]{
                e = st[len(st)-1]
                st = st[:len(st)-1]
                index--
            }
            e.Left = &TreeNode{postCur, nil, nil}
            st = append(st, e.Left)
        }
    }
    return root
}
```

## [654. 最大二叉树](https://leetcode-cn.com/problems/maximum-binary-tree/)

```go
func constructMaximumBinaryTree(nums []int) *TreeNode {
    if len(nums) <1{return nil}
    maxn,maxi := nums[0],0
    for i,v := range nums{
        if v > maxn{
            maxn=v; maxi=i
        }
    }
    root:=&TreeNode{maxn, nil, nil}
    root.Left = constructMaximumBinaryTree(nums[:maxi])
    root.Right = constructMaximumBinaryTree(nums[maxi+1:])
    return root
}
```

## [617. 合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)

```go
func mergeTrees(root1 *TreeNode, root2 *TreeNode) *TreeNode {
    if root1 == nil{return root2}
    if root2 == nil{return root1}
    // 修改当前节点
    root1.Val += root2.Val
    root1.Left = mergeTrees(root1.Left, root2.Left)
    root1.Right = mergeTrees(root1.Right, root2.Right)
    return root1
}   
```

- 非递归

```go
func mergeTrees(root1 *TreeNode, root2 *TreeNode) *TreeNode {
    if root1==nil{return root2}
    if root2==nil{return root1}
    type pair struct{
        root1 *TreeNode
        root2 *TreeNode
    }
    st := []pair{{root1,root2}}
    for len(st)>0{
        p := st[0]
        st = st[1:]
        e1, e2 := p.root1, p.root2
        if e1!=nil&&e2!=nil{
            e1.Val += e2.Val
            if e1.Left!=nil && e2.Left != nil{
                st = append(st, pair{e1.Left, e2.Left})
            }
            if e1.Right!=nil && e2.Right != nil{
                st = append(st, pair{e1.Right, e2.Right})
            }
            if e1.Left == nil && e2.Left!=nil{//e1左为空，把e2左值赋过去
                e1.Left = e2.Left
            }
            if e1.Right == nil && e2.Right != nil{//e1右同理
                e1.Right = e2.Right
            }
            //e2的不用管
        }

    }
    return root1
}
```

```go
// 这里有个巨坑，循环分清楚传进来的节点，和从队列取出的节点啊
func mergeTrees1(root1 *TreeNode, root2 *TreeNode) *TreeNode {
    if root1 ==nil{return root2}
    if root2 ==nil{return root1}

    queue := []*TreeNode{root1, root2}
    
    for len(queue) != 0{
        cur1, cur2 := queue[0], queue[1]
        queue = queue[2:]

        // fmt.Println(queue)
        cur1.Val += cur2.Val
        // 两个左孩子都不空
        if cur1.Left!=nil && cur2.Left != nil{
            queue = append(queue, cur1.Left, cur2.Left)
        }
        
        // 两个右孩子都不空
        if cur1.Right!=nil && cur2.Right != nil{
            queue = append(queue, cur1.Right, cur2.Right)
        }
        // 如果左空，右不空
        if cur1.Left == nil && cur2.Left != nil{
            cur1.Left = cur2.Left
            cur2.Left.Val = 0
        }
        if cur1.Right == nil && cur2.Right != nil{
            cur1.Right = cur2.Right
            cur2.Right.Val = 0
        }
    }
    return root1
}
```

# 二叉搜索树属性

二叉搜索树一般性质：

- 中序遍历为自增序列
- 根节点可以往下二分询问

## [700. 二叉搜索树中的搜索](https://leetcode-cn.com/problems/search-in-a-binary-search-tree/)

```go
func searchBST(root *TreeNode, val int) *TreeNode {
    // return searchBST1(root, val)
    return searchBST2(root, val)
}
// 二分
func searchBST1(root *TreeNode, val int) *TreeNode {
    if root == nil{return nil}
    if root.Val < val{
        return searchBST(root.Right, val)
    }
    if root.Val > val{
        return searchBST(root.Left, val)
    }
    return root
}
// 顺序
func searchBST2(root *TreeNode, val int) *TreeNode {
    if root == nil{return nil}
    if root.Val == val{return root}
    left := searchBST(root.Left, val)
    if left != nil{return left}
    right := searchBST(root.Right, val)
    if right != nil{return right}
    return nil
}
```

## [98. 验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

```go
func isValidBST(root *TreeNode) bool {
    pre:=-1<<32
    var dfs func(root *TreeNode)bool
    dfs = func(root *TreeNode)bool{
        if root == nil{return true}
        l := dfs(root.Left)
        if root.Val <= pre{return false}
        pre = root.Val
        r := dfs(root.Right)
        return l&&r
    }
    return dfs(root)
}
```

- 非递归

```go
func isValidBST(root *TreeNode) bool {
    if root == nil{return true}
    pre := -1<<32
    st := []*TreeNode{}
    for root != nil || len(st)>0{
        if root != nil{
            st = append(st, root)
            root = root.Left
        }else{
            e := st[len(st)-1]
            st = st[:len(st)-1]
            if e.Val <= pre{return false}
            pre = e.Val
            root = e.Right
        }
    }
    return true
}
```

## [530. 二叉搜索树的最小绝对差](https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst/)

```go
func getMinimumDifference(root *TreeNode) int {
    pre,curMin := -1, 1<<32
    var dfs func(root *TreeNode)
    dfs = func(root *TreeNode){
        if root == nil{return }
        dfs(root.Left)
        if pre != -1 && root.Val-pre < curMin{
            curMin = root.Val-pre
        }
        pre = root.Val
        dfs(root.Right)
    }
    dfs(root)
    return curMin
}
```

- 非递归

```go
func getMinimumDifference(root *TreeNode) int {
    if root == nil{return 0}
    pre,curMin := -1, 1<<32
    st := []*TreeNode{root}
    for len(st)>0{
        e := st[len(st)-1]
        if e!=nil{
            st = st[:len(st)-1]
            if e.Right!=nil{st =append(st, e.Right)}
            st =append(st, e, nil)
            if e.Left !=nil{st =append(st, e.Left)}
        }else{
            e = st[len(st)-2]
            st = st[:len(st)-2]
            if pre!=-1{
                curMin = min(curMin, e.Val-pre)
            }
            pre = e.Val
        }
    }
    return curMin
}

func min(a,b int)int{if a<b{return a};return b}
```

## [501. 二叉搜索树中的众数](https://leetcode-cn.com/problems/find-mode-in-binary-search-tree/)

```go
func findMode(root *TreeNode) (res []int) {
    if root == nil {return []int{}}
    st := []*TreeNode{root}
    // res = append(res, root.Val)
    c,maxn := 0,0
    pre := -1
    for len(st)>0{
        e := st[len(st)-1]
        if e!=nil{
            st = st[:len(st)-1]
            if e.Right!=nil{st = append(st, e.Right)}
            st = append(st, e, nil)
            if e.Left!=nil{st = append(st, e.Left)}
        }else{
            e = st[len(st)-2]
            st = st[:len(st)-2]
            if pre!=-1&&pre == e.Val{
                c++
            }else if pre!= -1&&pre!=e.Val{
                c=0
            }
            // 更新
            if c>maxn{
                maxn=c
                res = []int{e.Val}
            }else if c==maxn{
                res = append(res, e.Val)
            }
            pre = e.Val
        }
    }
    return
}
```

# 二叉树公共祖先

## [236. 二叉树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/)

```go
func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
    if root == nil || root == q || root == p{return root}
    left :=  lowestCommonAncestor(root.Left, p, q)
    right := lowestCommonAncestor(root.Right, p, q)
    if left != nil&&right != nil{return root}
    if left != nil && right == nil{return left}
    if left == nil && right != nil{return right}
    return nil
}
```

```go
func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
    if root == nil || root == q || root == p{return root}
    left :=  lowestCommonAncestor(root.Left, p, q)
    right := lowestCommonAncestor(root.Right, p, q)
    if left != nil&&right != nil{return root}
    if left == nil {return right}
    return left
}
```

## [235. 二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)

```go
func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
    //二分问询，注意这里需要同时与两个节点比较, 返回值也是递归后的，别忘了return
    if root.Val >p.Val&&root.Val>q.Val{
        return lowestCommonAncestor(root.Left, p, q)
    }else if root.Val < p.Val && root.Val <q.Val{
        return lowestCommonAncestor(root.Right, p, q)
    }
    return root
}
```

```go
func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
	for root!=nil{
        if root.Val > p.Val && root.Val >q.Val{
            root = root.Left
        }else if root.Val < p.Val && root.Val <q.Val{
            root = root.Right
        }else{
            return root
        }
    }
    return root
}
```

# 操作二叉树

通过递归函数返回值完成了新加⼊节点的⽗⼦关系赋值操作了，下⼀层将加⼊节点返回，本层⽤root->left或者root->right将其接住。  

## [701. 二叉搜索树中的插入操作](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/)

```go
func insertIntoBST(root *TreeNode, val int) *TreeNode {
    if root == nil{
        return &TreeNode{val,nil,nil}
    }
    if root.Val > val{root.Left = insertIntoBST(root.Left, val)}
    if root.Val < val{root.Right = insertIntoBST(root.Right, val)}
    return root
}
```

- 非递归

```go
func insertIntoBST(root *TreeNode, val int) *TreeNode {
    if root == nil{return &TreeNode{val,nil,nil}}
    var parent *TreeNode
    dummy := root
    for root != nil{
        parent = root
        if root.Val > val{
            root = root.Left
        }else{
            root = root.Right
        }
    }
    newNode := &TreeNode{val,nil,nil}
    if parent.Val > val{parent.Left = newNode}else{parent.Right = newNode}
    return dummy
}
```

```go
func insertIntoBST(root *TreeNode, val int) *TreeNode {
    if root == nil{return &TreeNode{val,nil,nil}}
    dummy := root
    for root!=nil{
        // 二分询问，值应该在当前节点的哪边
        if root.Val > val{
            if root.Left!=nil{
                root=root.Left
            }else{
                root.Left=&TreeNode{val,nil,nil}
                return dummy
            }
        }else if root.Val < val{
            if root.Right !=nil{
                root=root.Right
            }else{
                root.Right = &TreeNode{val,nil,nil}
                return dummy
            }
        }
    }
    return dummy
}
```

## [450. 删除二叉搜索树中的节点](https://leetcode-cn.com/problems/delete-node-in-a-bst/)

五种情况：

1.没找到删除的节点，遍历到空节点直接返回

2.左右都为空，直接删除节点，返回nil为根节点

3.删除节点左孩子空，删除节点，右孩子补位，返回右孩子为根节点

4.删除节点右孩子空，删除后，左孩子补位，返回左孩子为根节点

5.第五种情况：左右孩子节点都不为空，则将删除节点的左子树头结点（左孩子）放到删除节点的右子树的最左面节点的左孩子上，返回删除节点右孩子为新的根节点。

![450.删除二叉搜索树中的节点](http://myimg.go2flare.xyz/img/008eGmZEly1gnbj3k596mg30dq0aigyz.gif)

```go
func deleteNode(root *TreeNode, key int) *TreeNode {
    if root == nil{return nil}
    if root.Val == key{
        if root.Left == nil && root.Right == nil{
            return nil
        }else if root.Left == nil && root.Right != nil{
            return root.Right
        }else if root.Left != nil && root.Right == nil{
            return root.Left
        }else{
            // 右左叶接左孩
            right := root.Right
            cur := right
            for cur.Left != nil{
                cur = cur.Left
            }
            cur.Left = root.Left
            return right
        }
    }
    root.Left = deleteNode(root.Left, key)
    root.Right = deleteNode(root.Right, key)
    return root
}
```

- 补充：普通二叉树的删除

普通二叉树删除节点（不使用BST的特性）

两步法：

第一步先找到key，将其与右孩子左叶交换

第二步找到key，用通过用的方法可以正好删除

```go
func deleteNode(root *TreeNode, key int) *TreeNode {
    if root == nil{return nil}
    if root.Val == key{
        if root.Right == nil{//第二次找到key，这一步正好可以删
            return root.Left
        }
        cur := root.Right
        for cur.Left!=nil{
            cur = cur.Left
        }
        cur.Val, root.Val = root.Val, cur.Val //第一次找到key，与右子树的最左叶交换，这里不用返回root
    }
    root.Left = deleteNode(root.Left, key)
    root.Right = deleteNode(root.Right, key)
    return root
}
```

- 非递归

```

```

## [669. 修剪二叉搜索树](https://leetcode-cn.com/problems/trim-a-binary-search-tree/)

```go
func trimBST(root *TreeNode, low int, high int) *TreeNode {
    if root == nil{return nil}
    // 当前节点<下界，修剪掉当前，右子树都大于当前，可以继续找递归找
    if root.Val < low {return trimBST(root.Right, low, high)}
    if root.Val > high {return trimBST(root.Left, low, high)}
    
    root.Left = trimBST(root.Left, low, high)
    root.Right = trimBST(root.Right, low, high)
    return root
}
```

- 非递归

```go
func trimBST(root *TreeNode, low int, high int) *TreeNode {
    if root == nil{return nil}
    //  root 不在[L,R]内，移动到范围内
    for root != nil && (root.Val<low || root.Val>high){
        if root.Val <low {
            root = root.Right
        }else{
            root = root.Left
        }
    }

    dummy := root
    // root 在[L,R]内,左孩子<low
    for root != nil{
        for root.Left != nil && root.Left.Val < low{
            root.Left = root.Left.Right
        }
        root = root.Left
    }
    root = dummy//回到头节点
    // root 在[L,R]内,左孩子<low
    for root != nil{
        for root.Right != nil && root.Right.Val > high{
            root.Right = root.Right.Left
        }
        root = root.Right
    }
    return dummy
}
```

## [108. 将有序数组转换为二叉搜索树](https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/)

```go
func sortedArrayToBST(nums []int) *TreeNode {
    if len(nums)<1{return nil}
    l,r := 0, len(nums)
    m := l+(r-l)>>1
    root := &TreeNode{nums[m], nil, nil}
    root.Left = sortedArrayToBST(nums[:m])
    root.Right = sortedArrayToBST(nums[m+1:])
    return root
}
```

- 非递归

```go
func sortedArrayToBST(nums []int) *TreeNode {
    type pair struct{
        node *TreeNode //节点
        left int //左区间下标
        right int //右区间下标
    }
    root := &TreeNode{Val:0}
    q := []pair{{root, 0, len(nums)-1}}
    // BFS
    for len(q)>0{
        e,l,r := q[0].node,q[0].left,q[0].right
        q = q[1:]
        m := l+(r-l)>>1
        e.Val = nums[m]
        if l<m{//可以从m切割，左子树构建
            e.Left = &TreeNode{Val:0}
            q = append(q, pair{e.Left, l, m-1})
        }
        if r>m{//可以从m切割，右子树构建
            e.Right = &TreeNode{Val:0}
            q = append(q, pair{e.Right, m+1, r})
        }
    }
    return root
}
```



## [538. 把二叉搜索树转换为累加树](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)

```go
func convertBST(root *TreeNode) *TreeNode {
    var pre *TreeNode
    var dfs func(root *TreeNode)
    dfs = func(root *TreeNode){
        if root == nil{return }
        dfs(root.Right)
        if pre != nil{
            root.Val += pre.Val
        }
        pre = root
        dfs (root.Left)
    }
    dfs(root)
    return root
}

```

- 非递归

```go
func convertBST(root *TreeNode) *TreeNode {
    // 反中序
    var pre *TreeNode
    st := []*TreeNode{}
    dummy := root
    for root != nil||len(st)>0{
        if root != nil{
            st = append(st, root)
            root = root.Right 
        }else{
            e := st[len(st)-1]
            st = st[:len(st)-1]
            if pre != nil{
                e.Val += pre.Val
            }
            pre = e
            root = e.Left
        }
    }
    return dummy
}
```

```go
func convertBST(root *TreeNode) *TreeNode {
    if root == nil{return nil}
    var pre *TreeNode
    st := []*TreeNode{root}
    dummy := root
    for len(st)>0{
        e := st[len(st)-1]
        if e!= nil{
            st = st[:len(st)-1]
            if e.Left != nil{st = append(st, e.Left)}
            st = append(st, e, nil)
            if e.Right != nil{st = append(st, e.Right)}
        }else{
            e = st[len(st)-2]
            st = st[:len(st)-2]
            if pre != nil{
                e.Val += pre.Val
            }
            pre = e
        }
    }
    return dummy
}
```

